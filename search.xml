<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django创建</title>
    <url>/2022/04/20/Django%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>Linux上一定不要在root下操作，务必新建一个用户，避免环境搭建错了只能格式化的问题<br>整体流程：租一台云服务器&#x2F;虚拟机也可，先创建普通用户，在该用户下拉取镜像，并创建容器，进入容器，创建普通用户，之后的操作就在这个用户下操作了</p>
<h1 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h1><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>在服务器新建用户<code>adduser xq</code><br>授予sudo权限 <code>usermod -aG sudo xq</code><br>进入用户xq:<code>su - xq</code><br>拉去需要的django镜像</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>ubuntu docker安装命令<code>curl -sSL https://get.daocloud.io/docker | sh</code><br>将镜像加载到本地<code>docker load -i 镜像</code><br><code>docker [contaienr] run -itd django</code>：创建并启动一个容器django<br><code>docker attach django</code>进入容器<br>在容器内创建用户xq01:<code>adduser xq01</code><br>授权:<code>usermod -aG sudo xq01</code><br><code>ctrl p + ctrl q</code> 挂起容器</p>
<p><strong>企业开发不建议使用ssh登录</strong><br><img src="/Django%E5%88%9B%E5%BB%BA/1.png"><br><strong>如果只是作为学习，可以使用ssh</strong><br>在.ssh 下创建config<br>写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host django</span><br><span class="line">    HostName 域名/ip</span><br><span class="line">    User username</span><br><span class="line">    Port 20000 # 端口自定义开放</span><br></pre></td></tr></table></figure>
<p>之后<code>ssh-keygen</code>生成公钥<br><code>ssh-copy-id django</code> 上传公钥到容器<br>即可 <code>ssh django</code> 登录</p>
<p><strong>django项目各个文件用处</strong><br><img src="/Django%E5%88%9B%E5%BB%BA/2.png"><br><code>templates</code>目录：管理html文件<br><code>urls</code>目录：管理路由，即链接与函数的对应关系<br><code>views</code>目录：管理http函数<br><code>models</code>目录：管理数据库数据<br><code>static</code>目录：管理静态文件，比如：<br>    css：对象的格式，比如位置、长宽、颜色、背景、字体大小等<br>    js：对象的逻辑，比如对象的创建与销毁、事件函数、移动、变色等<br>    image：图片<br>    audio：声音</p>
<p><code>consumers</code>目录：管理websocket函数</p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2022/04/20/vim/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p><strong>跳转到第n行：</strong><br><code>esc nG</code>,跳到最后一行：G<br>或者：<code>esc: n</code></p>
<p><strong>光标向后移动n：</strong><br><code>esc n&lt;space&gt;</code></p>
<p><strong>向下跳n行：</strong><br><code>esc n&lt;enter&gt;</code></p>
<p><strong>查找字符串：</strong><br>光标之下寻找第一个word：<code>/word</code><br>光标之上寻找第一个word:<code>?word</code><br>重复前一个查找操作：<code>esc n</code><br>反向重复:<code>esc N</code></p>
<p><strong>批量修改：</strong><br>修改全文：<code>esc: 1,$s/word1/word2/g</code><br>修改某些行：<code>esc: n1,n2s/word1/word2/g</code>，将n1到n2行的word1替换成word2，s和g默认要写<br>若要访问权限：<code>esc: n1,n2/word1/word2/gc</code> 可以修改任意位置的word</p>
<p><strong>选中文本：</strong><br>选中：<code>esc v</code><br>取消选中：连按两次esc<br>剪切选中文本:<code>d</code><br>剪切本行：<code>esc dd</code><br>若复制粘贴在vi中操作，执行以下操作，若在vi内外操作，使用ctrl+insert shift+insert<br>复制选中文本:<code>y</code><br>复制本行：<code>yy</code><br>粘贴文本：<code>p</code><br>撤销：<code>u</code><br>取消撤销：<code>ctrl + r</code></p>
<p><strong>缩进：</strong><br>右缩进：<code>esc shift &gt;</code>  注意是shift左边的</p>
<p>左缩进：<code>esc shift &lt;</code></p>
<p><strong>取消查找文本高亮：</strong><br><code>:noh</code></p>
<p><strong>取消行号：</strong><br><code>esc: set nonu</code><br><strong>设置行号：</strong><br><code>esc: set nu</code></p>
<p><strong>光标定位：</strong><br>移到行首：<code>esc home键</code><br>移到行尾：<code>esc end键</code></p>
<p><strong>删除全文：</strong><br><code>esc ggdG</code>等于 1GdG</p>
<p><strong>全文格式化</strong><br>代码码风不完美可以用来优化<br><code>gg=G</code></p>
<p><strong>粘贴代码考虑到缩进等问题，我们采用</strong><br><code>set paste</code>取消缩进<br>再进行粘贴<br><code>set nopaste</code>开启缩进</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2022/04/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>感谢wzd的解释和知乎大佬的图解：<a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
<p><strong>主要用于解决一些元素分组问题，管理一系列不相交的集合</strong></p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p><strong>查找：</strong> 查找两个元素是否在同一个集合</p>
<p><strong>合并：</strong>将两个集合合并</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>**fa[]:**元素的父节点</p>
<p><strong>r[]:</strong> 秩(树的高度)</p>
<p><strong>根节点，父节点：</strong>根节点的标志就是父节点是本身</p>
<h2 id="并查集使用及优化"><a href="#并查集使用及优化" class="headerlink" title="并查集使用及优化"></a>并查集使用及优化</h2><h3 id="引例："><a href="#引例：" class="headerlink" title="引例："></a>引例：</h3><p>存在五个人 1 ~ 5 ，他们存在一定的追随关系</p>
<p><img src="/%E5%B9%B6%E6%9F%A5%E9%9B%86/1.png"></p>
<p>如图所示的追随关系就是并查集的简单案例</p>
<p>可以看到这就像相当于树</p>
<h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">        r[i] = 1;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="朴素版查找根节点："><a href="#朴素版查找根节点：" class="headerlink" title="朴素版查找根节点："></a>朴素版查找根节点：</h3><p>使用fa数组存储每个元素的父节点，初始化元素本身是父节点,当元素父节点不是本身，递归一层层查找父节点，但递归的查找效率是很慢的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    if(fa[x] == x)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        return find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="路径压缩查找根节点"><a href="#路径压缩查找根节点" class="headerlink" title="路径压缩查找根节点:"></a>路径压缩查找根节点:</h3><p>让每个元素都知道自己的根节点是谁，这样find最多使用两次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">	if(fa[x] != x) fa[x] = find(x);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p><img src="/%E5%B9%B6%E6%9F%A5%E9%9B%86/2.png"></p>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>朴素版查找根节点，每个元素只知道父节点，但不知道根节点，比如小a只知道他爸爸是谁，但他祖宗是谁不知道，于是他爸爸又找爷爷，爷爷又找爷爷的爸爸…</p>
<p>一代代询问</p>
<p>路径压缩，优化点就在于，从根节点的第一个追随者，如图中的2，2知道了他的父节点也是根节点是1，到了3，3就find(fa[3]) ,fa[3] 是 2，2知道它的根节点是1，所以对于3，find最多使用2次，就知道根节点是谁了</p>
<h3 id="朴素版合并："><a href="#朴素版合并：" class="headerlink" title="朴素版合并："></a>朴素版合并：</h3><p>这里假设合并的元素不同</p>
<p>这里让后者合并到前者里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int x, int y)&#123;</span><br><span class="line">	int a = find(x), b = find(y);</span><br><span class="line">	fa[b] = fa[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按秩合并："><a href="#按秩合并：" class="headerlink" title="按秩合并："></a>按秩合并：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int x, int y)&#123;</span><br><span class="line">	int a = find(x), b = find(y);</span><br><span class="line">	if (r[a] &gt;= r[b]) fa[b] = fa[a];</span><br><span class="line">	else fa[a] = fa[b];</span><br><span class="line">	if (r[a] == r[b]) r[a] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h3><p><img src="/%E5%B9%B6%E6%9F%A5%E9%9B%86/3.png"></p>
<p>很明显，1合并给8会让整个查找根节点的路径变长，路径压缩也需要时间，因此，我们引入按秩合并（秩：树的高度）</p>
<p>要求让秩小的合并到秩大的集合中，如上图，秩小的合并到秩大的集合，秩大的集合的秩是不变的</p>
<p>解释代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (r[a] == r[b]) r[a] ++;</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%B9%B6%E6%9F%A5%E9%9B%86/4.png"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</span><br><span class="line"></span><br><span class="line">现在要进行 m 个操作，操作共有三种：</span><br><span class="line"></span><br><span class="line">C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</span><br><span class="line">Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</span><br><span class="line">Q2 a，询问点 a 所在连通块中点的数量；</span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 n 和 m。</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q1 a b，如果 a 和 b 在同一个连通块中，则输出 Yes，否则输出 No。</span><br><span class="line"></span><br><span class="line">对于每个询问指令 Q2 a，输出一个整数表示点 a 所在连通块中点的数量</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n,m≤105</span><br><span class="line">输入样例：</span><br><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br><span class="line">输出样例：</span><br><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>思路：并查集的查询与合并，唯一不同的是可能会合并两个相同的元素，合并时特判即可</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int fa[N];</span><br><span class="line">int r[N];</span><br><span class="line">int cnt[N];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">        r[i] = 1;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        cnt[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    if (fa[x] != x) fa[x] = find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(int x, int y)&#123;</span><br><span class="line">    int a = find(x), b = find(y);</span><br><span class="line">    if (r[a] &gt;= r[b] &amp;&amp; a != b)&#123; // 根节点相同就不用合并了</span><br><span class="line">        cnt[a] += cnt[b];</span><br><span class="line">        fa[b] = fa[a];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (r[a] &lt; r[b])&#123;</span><br><span class="line">        cnt[b] += cnt[a];</span><br><span class="line">        fa[a] = fa[b];</span><br><span class="line">    &#125;</span><br><span class="line">    if (r[a] == r[b] &amp;&amp; a != b) r[a] ++;  //  排除根节点相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    while(m --)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        if (s == &quot;C&quot;) &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            merge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s == &quot;Q1&quot;) &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            if(find(a) == find(b)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">            else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            cout &lt;&lt; cnt[find(a)] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和&amp;&amp;差分</title>
    <url>/2022/04/20/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>前缀和 与 差分可以理解为&#x3D;&#x3D;互逆&#x3D;&#x3D;的 ， 求前缀和 跟 差分通常设数组首项下标为1，方便思考的计算。</p>
<h1 id="一维前缀和介绍"><a href="#一维前缀和介绍" class="headerlink" title="一维前缀和介绍"></a>一维前缀和介绍</h1><p>对于一维数组 a[n] , 存在数组 sum[n],使得 sum[i] &#x3D; a[1] + a[2] + … + a[i]</p>
<h1 id="前缀和优势"><a href="#前缀和优势" class="headerlink" title="前缀和优势"></a>前缀和优势</h1><p>以O(1)的时间复杂度得到某块区间的总和<br>举个例子：<br><strong>输入一个长度为 n 的整数序列。<br>接下来再输入 m 个询问，每个询问输入一对 l,r。<br>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</strong><br>常规算法 是两遍for循环求区间和，题目范围小还可以接受，若是开到1e5+，必然会爆int的。所以这里使用前缀和让时间复杂度降到O(1)<br>一维前缀和相对较简单，不做过多介绍</p>
<h1 id="二维前缀和介绍"><a href="#二维前缀和介绍" class="headerlink" title="二维前缀和介绍"></a>二维前缀和介绍</h1><p>如果数组变成二维数组又该怎么做呢，做法与一维前缀和相类似，只是多了个容斥原理<br>如果我们要求给定坐标的前缀和，如图<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/1.png" alt="在这里插入图片描述"><br>若果我们要求（3，3）的前缀和 ， 先算出（3，2），（2，3）的和，再减去图中红绿交汇的部分即（2，2） ，再加上坐标（3，3）的数值，就可以求出（3，3）的和</p>
<p>因此，&#x3D;&#x3D;二维前缀和公式&#x3D;&#x3D;：<strong>s[i][j] &#x3D; s[i-1][j] + s[i][j-1] - s[i-1][j-1] +a[i][j]</strong></p>
<p>那么怎么求任意矩阵任意位置坐标的和呢<br>比如<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/2.png" alt="在这里插入图片描述"><br>我们要求(x1,y1)到（x2,y2）前缀和，那么就是求图中红色区域，那么用（x2,y2)的前缀和（3*3矩阵）- 绿色区域 - 蓝色区间 + 绿兰交汇区域<br>因此，求&#x3D;&#x3D;任意区域的前缀和公式&#x3D;&#x3D;也很容易得出：<br><strong>ans &#x3D; s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]</strong></p>
<h1 id="二维前缀和模板题"><a href="#二维前缀和模板题" class="headerlink" title="二维前缀和模板题"></a>二维前缀和模板题</h1><p><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/3.png" alt="在这里插入图片描述"><br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/4.png" alt="在这里插入图片描述"><br>很典型的二维前缀模板题<br>思路 ： 先求前缀和 ， 再利用公式<strong>ans &#x3D; s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]</strong>    求出答案即可<br>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line">using namespace std ; </span><br><span class="line">const int N = 1e3 + 10 ; </span><br><span class="line">int a[N][N];</span><br><span class="line">int sum[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m , n , q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">	for (int i = 1 ; i &lt;= n ; i ++)</span><br><span class="line">		for (int j = 1 ; j &lt;= m ; j ++)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	//求前缀和</span><br><span class="line">	for (int i = 1 ; i &lt;= n ; i ++)</span><br><span class="line">		for (int j = 1 ; j &lt;= m ; j ++)</span><br><span class="line">			sum[i][j] = sum[i-1][j] + sum[i][j-1] -sum[i-1][j-1] +a[i][j];</span><br><span class="line">	// 求指定区间的和</span><br><span class="line">	while (q --)&#123;</span><br><span class="line">		int x1 , x2 , y1 , y2 ;</span><br><span class="line">		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 ;</span><br><span class="line">		cout &lt;&lt; sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1] &lt;&lt;endl; </span><br><span class="line">	&#125;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><p>类似于数学中的求导和积分，<strong>差分可以看成前缀和的逆运算。</strong></p>
<p>首先我们给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];</p>
<p>然后我们构造一个数组b ： b[1] ,b[2] , b[3],,,,,, b[i];</p>
<p>使得 a[i] &#x3D; b[1] + b[2 ]+ b[3] +,,,,,, + b[n];<br>也就是说，我们原始的数组是我们构造的数组的<strong>前缀和。</strong><br>那么我们如何求差分数组呢？<br>b[1] &#x3D; a[1] - a[0];<br>b[2] &#x3D; a[2] - a[1];<br>b[3] &#x3D;a [3] - a[2];<br>……..<br>b[n] &#x3D; a[n] - a[n-1];<br>因此通过数组b，我们可以在O（1）内对原始数组进行改造</p>
<h1 id="一维差分例题"><a href="#一维差分例题" class="headerlink" title="一维差分例题"></a>一维差分例题</h1><p><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/5.png" alt="在这里插入图片描述"><br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/6.png" alt="在这里插入图片描述"><br>题意很简单，就是给定区间 ， 对原数组进行修改。<br>常规做法，两层循环，复杂度O（n<em>m) 写法很简单，但必爆int。<br>简单梳理一下，为什么会跟差分有关联。<br>给定区间[l ,r ]，让我们把a数组中的[ l, r]区间中的每一个数都加上c,即 a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c。<br>所以，只要对差分数组b[n]加上c，那么它的前缀和数组a[n]也会因此而改变。比如b[k]+c，那么a[k]及其往后的数全部要加k。<br>所以当给定我们一个区间，做法也是同样的：<br>首先让差分数组b中的 b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c。<br>然后 <strong>b[r+1] - c</strong>, 通过前缀和运算，a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c。<br>这里为什么要有*<em>b[r+1] - c</em></em>  呢？下面画图解释一下：<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/7.png" alt="在这里插入图片描述"><br>我们要让[l,r]区间的原始数组a的数值变化，通过b[l]+c,让a[l]及其之后的数组都+c，但r之后的数我们并不想让它+c，所以我们还要让r之后的数组-c。<br>所以，<strong>b[r+1] - c</strong>就是这个道理。<br>代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line">using namespace std ; </span><br><span class="line">const int N = 1e5 + 10 ; </span><br><span class="line">int a[N];</span><br><span class="line">int b[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n , t ; </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">	for (int i = 1 ; i &lt;= n ; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i] - a[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	while (t --)&#123;</span><br><span class="line">		int l , r , c ;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; c ;</span><br><span class="line">		b[l] += c;</span><br><span class="line">		b[r+1] -= c;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1 ; i &lt;= n ; i++)&#123;</span><br><span class="line">		b[i] += b[i-1];// 求前缀和，就是求a的各项</span><br><span class="line">		cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>二维差分和二维前缀和都运用到了容斥原理<br>同样，a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组。<br>那么a数组中a[i][j]是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。</p>
<p><strong>如何构造二维差分数组</strong><br>对于差分，我们始终要记住，b[i][j]的改变会影响a[i][j]及其之后的元素。<br>若b数组已经构造好，让指定区域的元素加上c<br>b[x1][y1] + &#x3D; c;<br>b[x1][y2+1] - &#x3D; c;<br>b[x2+1][y1] - &#x3D; c;<br>b[x2+1][y2+1] + &#x3D; c;<br>我们画个图来理解一下<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/8.png" alt="在这里插入图片描述"><br>比如我们要改变的区间是在(x1,y1)到(x2,y2)<br>首先对b[x1][y1]+c ，就是图中红色区域。<br>再对绿色和紫色区域操作: b[x1][y2+1] - c ,b[x2+1][y1] - c.<br>又因为粉色重叠部分多减了一次，再加上 b[x2+1][y2+1] + c。<br><strong>再详细分析一下</strong><br>我们要求这个区域：<br><img src="/9.png" alt="在这里插入图片描述"><br>必然先要求这个区域：<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/10.png" alt="在这里插入图片描述"><br>再求这两个区域：<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/11.png" alt="在这里插入图片描述"><br>最后减去交汇的区域<br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/12.png" alt="在这里插入图片描述"></p>
<p>我们对原始数组进行区域增减，实际上就是对b数组的增减,通过这个方法创造差分数组。<br>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">     	b[i][j] += c;</span><br><span class="line">     	b[i+1][j] -= c;</span><br><span class="line">     	b[i][j+1] -= c;</span><br><span class="line">     	b[i+1][j+1] += c;	</span><br><span class="line">     &#125;</span><br><span class="line">就等同于对原始数组进行修改</span><br><span class="line">for (int i = 1 ; i &lt;= n ; i ++)</span><br><span class="line">	for (int j = 1; j &lt;= m ; j ++)</span><br><span class="line">		a[i][j] += c;</span><br></pre></td></tr></table></figure>
<p>假设a，b数组均为空，实际上不为空。我们每次让以(i,j)为左上角到以(i,j)为右上角面积内元素(其实就是一个小方格的面积)去插入 c&#x3D;a[i][j],等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行n*m次插入操作，就成功构建了差分b数组.</p>
<h1 id="二维差分习题"><a href="#二维差分习题" class="headerlink" title="二维差分习题"></a>二维差分习题</h1><p><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/13.png" alt="在这里插入图片描述"><br><img src="/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/14.png" alt="在这里插入图片描述"><br>和上面讲的思路完全一样，直接上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000 + 10;</span><br><span class="line"></span><br><span class="line">int a[N][N];</span><br><span class="line">int b[N][N];</span><br><span class="line"></span><br><span class="line">int n, m, q;</span><br><span class="line"></span><br><span class="line">void insert(int x1, int y1, int x2, int y2, int c)&#123; // 写成函数形式方便操作</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + 1] -= c;</span><br><span class="line">    b[x2 + 1][y1] -= c;</span><br><span class="line">    b[x2 + 1][y2 + 1] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,a[i] + j);</span><br><span class="line">            insert(i, j, i, j, a[i][j]); //</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        int x1,y1,x2,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;  // 根据二维前缀和的定义来对原数组进行复原，注意这里不是二维前缀和的操作，而是以某点为右下角的前缀和数组的构造</span><br><span class="line">        for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">注意a是b的前缀和， b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1]，移项就能求出a[i][j]。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>python打包</title>
    <url>/2022/04/20/python%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p><strong>先进入到要打包的文件&#x2F;文件夹的目录下</strong><br><code>pyinstaller -F -w (-i icofile) 文件名.py</code><br>解释一下该命令：<br>1、-w 表示在打包好程序后，双击.exe文件不会出现黑色的命令窗口。（如果你的程序有print等输出命令，则输出的内容就在此命令窗口中显示）<br>2、小括号中的内容是可以省略的，-i 表示给.exe文件一个图标，icofile表示图标的文件名，图标的图片格式为.ico格式的。不懂.ico图片的可以百度一下。打包时如果需要给.exe加入图标，将图标文件放到和.py文件同一目录下。<br>3、文件名.py 这里的文件名是你要打包的.py文件的名称。<br>4.ico制作地址:<a href="http://www.ico51.cn/">传送门</a></p>
]]></content>
      <categories>
        <category>python3</category>
      </categories>
  </entry>
  <entry>
    <title>数组模拟链表</title>
    <url>/2022/04/23/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>在算法中，用数组模拟链表(静态链表)，可以避免c++中每一次new的底层涉及内存分配，调用构造函数，指针转换等多种复杂且费时的操作。缺点是，这种操作不能实现真正意义上的删除，因此，若要长期的使用的话，需要使用动态链表，但在比赛中避免要TLE，需要数组模拟链表</strong></p>
<h1 id="数组模拟单链表："><a href="#数组模拟单链表：" class="headerlink" title="数组模拟单链表："></a>数组模拟单链表：</h1><h2 id="单链表的结点性质："><a href="#单链表的结点性质：" class="headerlink" title="单链表的结点性质："></a>单链表的结点性质：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e数组：存储每个结点的值</span><br><span class="line"></span><br><span class="line">ne数组：表示当前结点的next指针，也就是下一个结点的坐标</span><br><span class="line"></span><br><span class="line">head:头结点的下标 作用：链表初始化的时候等于−1，表示链表为空，二：指向下一个结点，即head=下标,“下标”**指的是下一个结点的下标**</span><br><span class="line"></span><br><span class="line">idx：存储当前已经用到了哪个点</span><br></pre></td></tr></table></figure>

<h2 id="单链表操作："><a href="#单链表操作：" class="headerlink" title="单链表操作："></a>单链表操作：</h2><h3 id="链表初始化："><a href="#链表初始化：" class="headerlink" title="链表初始化："></a>链表初始化：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head = -1;/* 最开始的时候，链表的头节点要指向-1，为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束,head作为一个特殊的指针，</span><br><span class="line">			 一开始指向空结点，当链表存在元素，head变成指向第一个结点的指针</span><br><span class="line">idx = 0; </span><br></pre></td></tr></table></figure>



<h3 id="在头结点插入一个节点x："><a href="#在头结点插入一个节点x：" class="headerlink" title="在头结点插入一个节点x："></a>在头结点插入一个节点x：</h3><p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/1.png"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = head;</span><br><span class="line">head = idx;</span><br><span class="line">idx ++;</span><br></pre></td></tr></table></figure>

<h3 id="在k位置之后的位置插入x"><a href="#在k位置之后的位置插入x" class="headerlink" title="在k位置之后的位置插入x"></a>在k位置之后的位置插入x</h3><p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/2.png"></p>
<p>代码实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k];</span><br><span class="line">ne[k] = idx;</span><br><span class="line">idx ++;</span><br></pre></td></tr></table></figure>

<h3 id="删除k位置之后的结点"><a href="#删除k位置之后的结点" class="headerlink" title="删除k位置之后的结点"></a>删除k位置之后的结点</h3><p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/3.png"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ne[k] = ne[ne[k]] </span><br></pre></td></tr></table></figure>

<p>可以看到，这里是静态链表很明显的问题，只是越过中间的结点，没有真正意义上实现删除结点</p>
<h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>题目来自yxc老师</p>
<p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/4.png"></p>
<p><strong>注意：</strong>我们思路中实现的k位置指的是下标,题目中的第k个数，由于我们下标从1开始，因此第k个数，下标为k-1</p>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int head, idx;</span><br><span class="line">int e[N], ne[N];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    head = -1;</span><br><span class="line">    idx = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_head(int x)&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k, int x)&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k)&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n --)&#123;</span><br><span class="line">        char c;</span><br><span class="line">        int k, x;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        if (c == &#x27;H&#x27;)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c == &#x27;I&#x27;)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k-1, x);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            if (!k) head = ne[head];</span><br><span class="line">            else remove(k-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数组模拟双链表"><a href="#数组模拟双链表" class="headerlink" title="数组模拟双链表:"></a>数组模拟双链表:</h1><h2 id="双链表结点性质"><a href="#双链表结点性质" class="headerlink" title="双链表结点性质:"></a>双链表结点性质:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 为左边界，1为右边界</span><br><span class="line">非空结点下标从2开始</span><br><span class="line">r[]:结点右侧的next指针</span><br><span class="line">l[]: 结点左侧的next指针</span><br></pre></td></tr></table></figure>

<h2 id="双链表操作："><a href="#双链表操作：" class="headerlink" title="双链表操作："></a>双链表操作：</h2><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>我们默认插入第k个位置右边的结点x，这样插入到k位置的左边也就是insert(l[k])</p>
<p><strong>注意：</strong>并不是insert(k-1)，随车链表的操作修改，k不一定代表第k个</p>
<p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/5.png"></p>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insert(int k, int x)&#123; // 在第k个位置右侧插入x</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/6.png"></p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void remove(int k)&#123; // 删除结点</span><br><span class="line">    l[r[k]] = r[k];</span><br><span class="line">    r[l[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="习题：-1"><a href="#习题：-1" class="headerlink" title="习题："></a>习题：</h2><p><img src="/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/7.png" alt="image-20220424181207822"></p>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    r[0] = 1;</span><br><span class="line">    l[1] = 0;</span><br><span class="line">    idx = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int k, int x)&#123; // 在第k个位置右侧插入x</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k)&#123; // 删除结点</span><br><span class="line">    l[r[k]] = r[k];</span><br><span class="line">    r[l[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    while(n --)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        int k, x;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        if (s == &quot;L&quot;)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(r[0], x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if (s == &quot;R&quot;)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(l[1], x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if (s == &quot;D&quot;)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            remove(k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if (s == &quot;IR&quot;)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k+1, x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k+1], x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2022/04/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序（英语：merge sort）是一种采用了 分治 思想的排序算法。</p>
<p>步骤 ：</p>
<p>step1: 将数列从中间划分为两部分</p>
<p>step2: 调用递归将左右两个子数列继续进行归并排序</p>
<p>step3:将两个有序的子序列合并成整个完整数列**（双指针）</p>
<p>时间复杂度 ：归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 O（nlogn）。</p>
<p>每递归一层， 每个数列会产生两层子数列</p>
<p>空间复杂度 O(n) </p>
<p>步骤1 取中间 </p>
<p>int mid &#x3D; (left+right)&#x2F;2;<br>步骤2   左右两个子数列继续归并</p>
<pre><code>merge_sort(a,left,mid);
merge_sort(a,mid+1,right);
</code></pre>
<p>步骤3    合并有序子数列</p>
<pre><code>int i = left , k = 0 ,j = mid + 1;
while (i&lt;=mid &amp;&amp; j &lt;= right)&#123;
    if (a[i]&lt;=a[j])
        tmp[k++] = a[i++];
    else 
        tmp[k++] = a[j++];
&#125;

while (i&lt;=mid)    tmp[k++] = a[i++];
while (j&lt;=right) 	tmp[k++] = a[j++];
</code></pre>
<p>步骤三详解</p>
<p>采用双指针对两个有序子数列进行合并、</p>
<p>比如左右两个有序子数列如下</p>
<p> 指针分别指向1 2 ，比较1和2大小，将小值存入空白数组tmp[n]</p>
<p>1的执政指向下一个数4</p>
<p>如此反复，直到其中一个有序子数列全部存完</p>
<p> tmp中已经存有 1~7 那么还剩8</p>
<p>于是便需要进行如下操作</p>
<pre><code>while (i&lt;=mid)    tmp[k++] = a[i++];
while (j&lt;=right) 	tmp[k++] = a[j++];
</code></pre>
<p>需要判断左右子列到底哪个没有读取完</p>
<p>最后将tmp备用数组的数读到自己设定的数列即可</p>
<p>完整代码如下 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span> ;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">1</span> ; </span><br><span class="line"><span class="type">int</span> a[N],tmp[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> a[] , <span class="type">int</span> left , <span class="type">int</span> right )</span>&#123;</span><br><span class="line">	<span class="comment">// 当数组长度为 1 or 0 要return、</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right )</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//将数列从中间划分为两部分</span></span><br><span class="line">	<span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//调用递归将左右两个子数列继续进行归并排序</span></span><br><span class="line">	merge_sort(a,left,mid);</span><br><span class="line">	merge_sort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">	<span class="comment">//将两个有序的子序列合并成整个完整数列</span></span><br><span class="line">	<span class="type">int</span> i = left , j = mid + <span class="number">1</span> , k = <span class="number">0</span> ;<span class="comment">//定义i为左子数列初始下标，j为右子数列初始下标，k为空白数组初始下标</span></span><br><span class="line">	<span class="keyword">while</span> ( i &lt;= mid &amp;&amp; j &lt;= right )&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]&lt;=a[j])</span><br><span class="line">			tmp[k++] = a[i++];</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			tmp[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下面将左或右子数列剩余的数归并到tmp后面</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)<span class="comment">//左子数列有剩余</span></span><br><span class="line">		tmp[k++] = a[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= right)<span class="comment">//右子数列有剩余</span></span><br><span class="line">		tmp[k++] = a[j++];</span><br><span class="line">	<span class="comment">// 将空白tmp[]转移到a[]</span></span><br><span class="line">	<span class="keyword">for</span> (i = left , j = <span class="number">0</span> ; i &lt;= right ; j++ , i ++ )</span><br><span class="line">		a[i] = tmp[j];</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n ; </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	merge_sort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>stl</title>
    <url>/2022/04/20/stl/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>（变长数组），倍增的思想，支持比较运算（按字典序）</span><br><span class="line">    定义：：</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="type">int</span>&gt; a; 定义：一个<span class="built_in">vector</span>数组a</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="type">int</span>&gt; a(<span class="number">10</span>); 定义：一个长度为<span class="number">10</span>的<span class="built_in">vector</span>数组a</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="type">int</span>&gt; a(<span class="number">10</span>,<span class="number">3</span>); 定义：一个长度为<span class="number">10</span>的<span class="built_in">vector</span>数组a，并且所有元素都为<span class="number">3</span></span><br><span class="line">    常用函数：：</span><br><span class="line">        size(); 返回元素个数</span><br><span class="line">        empty(); 返回是否是空</span><br><span class="line">        clear(); 清空</span><br><span class="line">        front(); 返回<span class="built_in">vector</span>的第一个数</span><br><span class="line">        back(); 返回<span class="built_in">vector</span>的最后一个数</span><br><span class="line">        push_back(); 向<span class="built_in">vector</span>的最后插入一个数</span><br><span class="line">        pop_back(); 把<span class="built_in">vector</span>的最后一个数删掉</span><br><span class="line">        begin(); <span class="built_in">vector</span>的第<span class="number">0</span>个数</span><br><span class="line">        end(); <span class="built_in">vector</span>的最后一个的数的后面一个数</span><br><span class="line">    倍增的思想：</span><br><span class="line">        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关</span><br><span class="line">    遍历方法</span><br><span class="line">        假设有个<span class="built_in">vector</span> &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        第一种：</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.size();i ++) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        第二种：</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">vector</span> &lt;<span class="type">int</span>&gt;::iterator i = a.begin();i != a.end();i ++) <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="built_in">vector</span> &lt;<span class="type">int</span>&gt;::iterator可以写为<span class="keyword">auto</span></span><br><span class="line">        第三种：</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>  x : a) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）</span><br><span class="line">    定义：：</span><br><span class="line">        <span class="built_in">pair</span> &lt;类型,类型&gt; 变量名;    两个类型可以不同</span><br><span class="line">    初始化方式：</span><br><span class="line">        假设有个<span class="built_in">pair</span> &lt;<span class="type">int</span>,<span class="built_in">string</span>&gt; p;</span><br><span class="line">        第一种：</span><br><span class="line">            p = <span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        第二种：</span><br><span class="line">            p = &#123;<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    常用函数：：</span><br><span class="line">        first(); 第一个元素</span><br><span class="line">        second(); 第二个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>（字符串）</span><br><span class="line">    常用函数：：</span><br><span class="line">        substr(); 返回每一个子串</span><br><span class="line">        c_str(); 返回这个<span class="built_in">string</span>对应的字符数组的头指针</span><br><span class="line">        size(); 返回字母个数</span><br><span class="line">        length(); 返回字母个数</span><br><span class="line">        empty(); 返回字符串是否为空</span><br><span class="line">        clear(); 把字符串清空</span><br><span class="line"><span class="built_in">queue</span>（队列）</span><br><span class="line">    定义：：</span><br><span class="line">        <span class="built_in">queue</span> &lt;类型&gt; 变量名;</span><br><span class="line">    常用函数：：</span><br><span class="line">        size(); 这个队列的长度</span><br><span class="line">        empty(); 返回这个队列是否为空</span><br><span class="line">        push(); 往队尾插入一个元素</span><br><span class="line">        front(); 返回队头元素</span><br><span class="line">        back(); 返回队尾元素</span><br><span class="line">        pop(); 把队头弹出</span><br><span class="line">        注意：队列没有clear函数！！！</span><br><span class="line">    清空：</span><br><span class="line">        变量名 = <span class="built_in">queue</span> &lt;<span class="type">int</span>&gt; ();</span><br><span class="line"><span class="built_in">priority_queue</span>（优先队列，堆）</span><br><span class="line">    注意：默认是大根堆！！！</span><br><span class="line">    定义：：</span><br><span class="line">        大根堆：<span class="built_in">priority_queue</span> &lt;类型&gt; 变量名;</span><br><span class="line">        小根堆：<span class="built_in">priority_queue</span> &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名</span><br><span class="line">    常用函数：</span><br><span class="line">        size(); 这个堆的长度</span><br><span class="line">        empty(); 返回这个堆是否为空</span><br><span class="line">        push();往堆里插入一个元素</span><br><span class="line">        top(); 返回堆顶元素</span><br><span class="line">        pop(); 弹出堆顶元素</span><br><span class="line">        注意：堆没有clear函数！！！</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>（栈）</span><br><span class="line">    常用函数：</span><br><span class="line">        size(); 这个栈的长度</span><br><span class="line">        empty(); 返回这个栈是否为空</span><br><span class="line">        push(); 向栈顶插入一个元素</span><br><span class="line">        top(); 返回栈顶元素</span><br><span class="line">        pop(); 弹出栈顶元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>（双端队列）</span><br><span class="line">    常用函数：</span><br><span class="line">        size(); 这个双端队列的长度</span><br><span class="line">        empty(); 返回这个双端队列是否为空</span><br><span class="line">        clear(); 清空这个双端队列</span><br><span class="line">        front(); 返回第一个元素</span><br><span class="line">        back(); 返回最后一个元素</span><br><span class="line">        push_back(); 向最后插入一个元素</span><br><span class="line">        pop_back(); 弹出最后一个元素</span><br><span class="line">        push_front(); 向队首插入一个元素</span><br><span class="line">        pop_front(); 弹出第一个元素</span><br><span class="line">        begin(); 双端队列的第<span class="number">0</span>个数</span><br><span class="line">        end(); 双端队列的最后一个的数的后面一个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>，<span class="built_in">map</span>，<span class="built_in">multiset</span>，<span class="built_in">multimap</span> 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">set</span>/<span class="built_in">multiset</span></span><br><span class="line">        注意：<span class="built_in">set</span>不允许元素重复，如果有重复就会被忽略，但<span class="built_in">multiset</span>允许！！！</span><br><span class="line">        常用函数：</span><br><span class="line">            size(); 返回元素个数</span><br><span class="line">            empty(); 返回<span class="built_in">set</span>是否是空的</span><br><span class="line">            clear(); 清空</span><br><span class="line">            begin(); 第<span class="number">0</span>个数，支持++或--，返回前驱和后继</span><br><span class="line">            end(); 最后一个的数的后面一个数，支持++或--，返回前驱和后继</span><br><span class="line">            insert(); 插入一个数</span><br><span class="line">            find(); 查找一个数</span><br><span class="line">            count(); 返回某一个数的个数</span><br><span class="line">            erase();</span><br><span class="line">                （<span class="number">1</span>）输入是一个数x，删除所有x    <span class="title function_">O</span><span class="params">(k + <span class="built_in">log</span> n)</span></span><br><span class="line">                （2）输入一个迭代器，删除这个迭代器</span><br><span class="line">            <span class="title function_">lower_bound</span><span class="params">(x)</span>; 返回大于等于x的最小的数的迭代器</span><br><span class="line">            upper_bound(x); 返回大于x的最小的数的迭代器</span><br><span class="line">    <span class="built_in">map</span>/<span class="built_in">multimap</span></span><br><span class="line">        常用函数：</span><br><span class="line">            insert(); 插入一个数，插入的数是一个<span class="built_in">pair</span></span><br><span class="line">            <span class="title function_">erase</span><span class="params">()</span>; </span><br><span class="line">                （<span class="number">1</span>）输入是<span class="built_in">pair</span></span><br><span class="line">                （<span class="number">2</span>）输入一个迭代器，删除这个迭代器</span><br><span class="line">            find(); 查找一个数</span><br><span class="line">            lower_bound(x); 返回大于等于x的最小的数的迭代器</span><br><span class="line">            upper_bound(x); 返回大于x的最小的数的迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_set</span>，<span class="built_in">unordered_map</span>，unordered_muliset,<span class="built_in">unordered_multimap</span> 基于哈希表</span><br><span class="line">    和上面类似，增删改查的时间复杂度是O(<span class="number">1</span>)</span><br><span class="line">    不支持lower_bound()和upper_bound()</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span> 压位</span><br><span class="line">    定义：</span><br><span class="line">        <span class="built_in">bitset</span> &lt;个数&gt; 变量名;</span><br><span class="line">    支持：</span><br><span class="line">        ~，&amp;，|，^</span><br><span class="line">        &gt;&gt;，&lt;&lt;</span><br><span class="line">        ==，!=</span><br><span class="line">        []</span><br><span class="line">    常用函数：</span><br><span class="line">        count(); 返回某一个数的个数</span><br><span class="line">        any(); 判断是否至少有一个<span class="number">1</span></span><br><span class="line">        none(); 判断是否全为<span class="number">0</span></span><br><span class="line">        <span class="built_in">set</span>(); 把所有位置赋值为<span class="number">1</span></span><br><span class="line">        <span class="built_in">set</span>(k,v); 将第k位变成v</span><br><span class="line">        <span class="title function_">reset</span><span class="params">()</span>; 把所有位变成<span class="number">0</span></span><br><span class="line">        flip(); 把所有位取反，等价于~</span><br><span class="line">        flip(k); 把第k位取反</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu下mysql8.0安装卸载以及用户授权</title>
    <url>/2022/04/20/ubuntu%E4%B8%8Bmysql8-0%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="切换镜像源"><a href="#切换镜像源" class="headerlink" title="切换镜像源"></a>切换镜像源</h2><p>在ubuntu内要提前切换好国内的镜像源，如阿里云，华为云，清华大学：<br>进入root<br>输入<code>apt-get update</code>更新镜像源</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>我们的ubuntu版本是20.4的，是支持mysql8.0,可以通过命令下载：<br>root下输入：<br><code>apt-get install mysql-server</code>下载服务端<br><code>apt-get install mysql-client</code>下载客户端<br><code>apt-get install libmysqlclient-dev</code><br>完成这三步之后输入<code>mysql -u root -p</code><br>首次输入要设置密码，设置后就可以root下使用了</p>
<h1 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h1><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p><code>CREATE USER &#39;usernamexxx&#39;@&#39;hostxxx&#39; IDENTIFIED BY &#39;passwordxxx&#39;;</code><br>本地用户@后写localhost，如‘keqing‘@’localhost’</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>GRANT privilegesxxx ON databasenamexxx.tablenamexxx TO ‘usernamexxx‘@’hostxxx’<br>说明：<br>privilegesxxx：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasenamexxx：数据库名<br>tablenamexxx：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*<br>如<code>grant all on database.* to &#39;keqing&#39;@&#39;localhost&#39;</code></p>
<h1 id="mysql完全卸载"><a href="#mysql完全卸载" class="headerlink" title="mysql完全卸载"></a>mysql完全卸载</h1><p>删除mysql的数据文件<br><code>sudo rm /var/lib/mysql/ -R</code><br>删除mysql的配置文件<br><code>sudo rm /etc/mysql/ -R</code></p>
<p>自动卸载mysql（包括server和client）<br><code>sudo apt-get autoremove mysql* --purge</code><br><code>sudo apt-get remove apparmor</code></p>
<p>卸载： <code>sudo apt-get remove dbconfig-mysql</code><br>卸载：<code>sudo apt-get remove mysql-client</code><br>卸载：<code>sudo apt-get remove mysql-client-5.7</code><br>卸载：<code>sudo apt-get remove mysql-client-core-5.7</code><br>再次执行自动卸载：<code>sudo apt-get autoremove mysql* --purge</code><br>卸载：<code>sudo apt-get remove php7.0-mysql</code><br>清除残留数据：<code>dpkg -l|grep ^rc|awk ‘&#123;print$2&#125;’|sudo xargs dpkg -P</code><br><a href="https://blog.csdn.net/weixin_45525272/article/details/107774348">详细卸载说明</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2022/04/20/ssh/</url>
    <content><![CDATA[<p>笔记摘自yxc</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><p><code>ssh user@hostname</code><br>指定端口：<br><code>ssh -p user@hostname</code>注意小写p</p>
<h3 id="修改登录名称"><a href="#修改登录名称" class="headerlink" title="修改登录名称"></a>修改登录名称</h3><p>在 <code>.ssh/config</code>中<br>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"># 如果有多台服务器</span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure>
<p>以此可以使用myserver1 myserver2的命名代替<code>ssh user@hostname</code>登录方式<br>即：<code>ssh myserver1</code>登录</p>
<h3 id="密钥登录（免密）"><a href="#密钥登录（免密）" class="headerlink" title="密钥登录（免密）"></a>密钥登录（免密）</h3><p>创建密钥：<br><code>ssh-keygen</code><br>在<code>~/.ssh/</code>下会找到两个文件：<br><code>id_rsa</code>：私钥<br><code>id_rsa.pub</code>：公钥<br>使用<code>ssh-copy-id myserver</code>命令一键添加公钥到服务器<br>添加位置在服务器的:<code>~/.ssh/authorized_keys</code></p>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>可以在自己的终端不登录服务器也可进行操作：<br><code>ssh user@hostname command</code>即可<br>如<code>ssh user@hostname ls -a</code></p>
<h2 id="scp传文件"><a href="#scp传文件" class="headerlink" title="scp传文件"></a>scp传文件</h2><p>命令格式：<code>scp source destination</code><br> 将source路径下的文件复制到destination中<br>一次复制多个文件<code>scp source1 source2 destination</code><br>复制文件夹：<code>scp -r source destination</code><br>家目录：<code>~/</code>   当前目录:<code>.</code><br>指定端口号：<code>scp -P 22 source1 source2 destination</code>注意是大写P</p>
<h3 id="scp配置服务器的vim和tmux："><a href="#scp配置服务器的vim和tmux：" class="headerlink" title="scp配置服务器的vim和tmux："></a>scp配置服务器的vim和tmux：</h3><p><code>scp ~/.vimrc ~/.tmux.conf myserver:</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/2022/05/17/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="dijkstra-用法"><a href="#dijkstra-用法" class="headerlink" title="dijkstra 用法"></a>dijkstra 用法</h2><p>用于求有向图最短路问题，求取起点到各个点的最短路</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>将顶点作为集合，已经确定最短路的最为哦一个集合s{}</p>
<p>其余的作为k{}, 将k中的定点依次加入s中，使得原点到s各顶点长度都不大与原点到k中任意点的最短路径距离</p>
<h2 id="样例模拟"><a href="#样例模拟" class="headerlink" title="样例模拟"></a>样例模拟</h2><p><img src="/Dijkstra%E7%AE%97%E6%B3%95/1.png"></p>
<h2 id="O-n-n-代码"><a href="#O-n-n-代码" class="headerlink" title="O(n*n)代码"></a>O(n*n)代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 500 + 10;</span><br><span class="line"></span><br><span class="line">int g[N][N],dist[N];</span><br><span class="line">bool st[N];</span><br><span class="line">int n, m;	</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	dist[1] = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">		int t = -1;</span><br><span class="line">		for (int j = 1; j &lt;= n; j ++)</span><br><span class="line">			if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) </span><br><span class="line">				t = j;</span><br><span class="line"></span><br><span class="line">		st[t] = true;</span><br><span class="line"></span><br><span class="line">		for (int j = 1; j &lt;= n; j ++)</span><br><span class="line">			dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	memset(g, 0x3f, sizeof g);</span><br><span class="line">	while (m --)&#123;</span><br><span class="line">		int a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		g[a][b] = min(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	dijkstra();</span><br><span class="line">	for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2022/04/20/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h1 id="二分查找介绍"><a href="#二分查找介绍" class="headerlink" title="二分查找介绍"></a>二分查找介绍</h1><ul>
<li>二分的<strong>本质</strong>是找到区间的一个分界点，使得包含分界点的区间满足某个性质，不含分界点的区间不满足这个性质，二分查找是基于有序序列的查找算法。</li>
<li>二分查找的<strong>高效</strong>之处在于，每一步都可以去除当前区间的一半元素，因此其时间复杂度时O(logn)。</li>
<li>举个<strong>例子</strong>：图书馆自习的时候,一女生背着一堆书进阅览室,结果警报响了,大妈让女生看是哪本书把警报弄响了，女生把书倒出来，一本一本的测。大妈见状急了，把书分成两份,第一份过了一下,响了。又把这一份分成两份接着测，三回就找到了，大妈用鄙视的眼神看着女生，仿佛在说 O(N)和  O(logN）都分不清。</li>
<li><strong>二分思想：每次将范围缩小一半 ， 确定范围内答案会被覆盖到 ， 当长度为1时，就是答案，整数二分模板要保证有解，不同题目可能会无解</strong></li>
</ul>
<h1 id="基本的二分查找应用"><a href="#基本的二分查找应用" class="headerlink" title="基本的二分查找应用"></a>基本的二分查找应用</h1><p><strong>查找序列中是否存在某条件的元素</strong><br>例如二分查找常用于解决最大值最小化  和 最小值最大化问题 </p>
<h1 id="二分查找解释"><a href="#二分查找解释" class="headerlink" title="二分查找解释"></a>二分查找解释</h1><ul>
<li><strong>首先</strong>，区间是有序的有单调性的，但二分本质不是单调性，有单调性一定可以二分，但可以二分不一定非要有单调性。<br>若要查到的一个数比目标值大，则右半部分的值也比目标值大，那么右半部分就可以舍弃了。同样查找的值比较小，就可以舍弃左半边。</li>
<li><strong>二分查找要满足</strong><br>1.当前待查找序列，肯定包含目标元素   2.每次待查找序列的规模都会变小。</li>
<li><strong>图解</strong>（借鉴于acwing yxc）<br>要找到一个性质可以将区间一分为二，一半满足一半不满足要求，则可以寻找绿色或者红色的边界。当在不同的边界，那么就产生不同的模板<br><img src="/%E4%BA%8C%E5%88%86/1.png"></li>
</ul>
<p><strong>对于红色边界</strong><br>是来寻找小于等于目标值的数<br><img src="/%E4%BA%8C%E5%88%86/2.png"><br><strong>绿色边界</strong><br>是来寻找大于等于目标值的数，因此左边界 l 要一直向右<br>这里为什么要mid &#x3D; l + r +1 &gt;&gt; 1呢，相加的整数的除法是向下取整，当l &#x3D; r - 1，若补不上1，向下取整 mid &#x3D; l，会陷入死循环。<br>补上后mid会等于r，即[r,r]。<br><img src="/%E4%BA%8C%E5%88%86/3.png"></p>
<h1 id="整数二分查找模板"><a href="#整数二分查找模板" class="headerlink" title="整数二分查找模板"></a>整数二分查找模板</h1><p><strong>二分查找模板有两个 ， 一是尽量往左找，二是尽量往右找</strong><br>整数的二分查找会更ex人 ， 看起来很简单 ，但经常会出错，要么纠结在mid是否+1 ， 要么纠结是否加等号。一个简便方法 ， 这里坐标记left -&gt; l，right -&gt;r.<br>本质一点就是观察更新区间的时候，写的是l &#x3D; mid还是r &#x3D; mid，如果是第一种，那么就是区间向右缩小，便是求末位置，反之便是求初始位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板一</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;	<span class="comment">//(l+r)/2</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid))  r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   模板二</span><br><span class="line">   	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;	<span class="comment">//(l+r+1)/2</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid))  l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单总结下这两个模板</strong><br>&#x3D;&#x3D;只要是往左找答案，就用第一个模板，mid不用加一，r&#x3D;mid，l减一；<br>只要是往右找答案，就用第二个模板，mid要加一，l&#x3D;mid，r要减一；&#x3D;&#x3D;</p>
<h1 id="二分查找模板题"><a href="#二分查找模板题" class="headerlink" title="二分查找模板题"></a>二分查找模板题</h1><p><img src="/%E4%BA%8C%E5%88%86/4.png"><br><img src="/%E4%BA%8C%E5%88%86/5.png"><br>查找元素在序列中的始末位置，很典型的二分查找例题，查找初始位置，套用模板一，查找末位置，套用模板二。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span> ; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span> ;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n , m , k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt;m; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">while</span> ( m -- )&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span> , r = n - <span class="number">1</span> ;  </span><br><span class="line">		<span class="keyword">while</span> ( l &lt; r )&#123;<span class="comment">//先查找第一次出现的位置</span></span><br><span class="line">			<span class="type">int</span> mid = r + l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[mid] &gt;= k)  r = mid ;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[l] != k)	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 查找不到元素，直接结束查找末位置</span></span><br><span class="line">		<span class="comment">//当始位置能够被查到，继续进行查找末位置</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			l = <span class="number">0</span> , r = n - <span class="number">1</span> ; <span class="comment">// 查找大于等于目标值的数，mid要加以避免向下取整死循环</span></span><br><span class="line">			<span class="keyword">while</span> ( l &lt; r )&#123;</span><br><span class="line">				<span class="type">int</span> mid = r + l + <span class="number">1</span> &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> ( a[mid] &lt;= k ) l = mid ;</span><br><span class="line">				<span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2022/04/26/KMP/</url>
    <content><![CDATA[<h3 id="y总对于KMP的解释"><a href="#y总对于KMP的解释" class="headerlink" title="y总对于KMP的解释"></a>y总对于KMP的解释</h3><p>kmp字符串匹配像追女生一样，追到一定进度觉得不太匹配，进度后退一部分，而不是从头再来，后退到一个的匹配的进度，继续追，不断执行匹配操作，若匹配上了，进度继续增加，不匹配，就退而求其次，知道追到手hh</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>字符串匹配操作，优化暴力枚举操作</p>
<p><strong>相关属性</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[] : 待匹配串</span><br><span class="line">p[] : 匹配串</span><br><span class="line">非平凡前缀: 除了最后一个字符，一个字符串的以头部字符为组合点的所有组合</span><br><span class="line">非平凡后缀: 除了第一个字符，一个字符串以尾部字符为组合点的所有组合</span><br><span class="line">部分匹配值：前缀和后缀共有的最长的字符串长度</span><br><span class="line">next[]: 部分匹配值表，存储每个下表对应的部分匹配值</span><br></pre></td></tr></table></figure>

<p><strong>思想：</strong>每次匹配失败，开始下一次匹配，不是从头开始，而是把匹配串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。</p>
<h3 id="next数组模拟"><a href="#next数组模拟" class="headerlink" title="next数组模拟"></a>next数组模拟</h3><p>我们手动模拟字符串 a b c a b 的next数组：</p>
<p><img src="/KMP/1.png"></p>
<h3 id="匹配串和待匹配串的匹配过程"><a href="#匹配串和待匹配串的匹配过程" class="headerlink" title="匹配串和待匹配串的匹配过程"></a>匹配串和待匹配串的匹配过程</h3><p><img src="/KMP/2.png"></p>
<p>当匹配到上图，s[a,b] &#x3D; p[1,j] 并且 s[i] !&#x3D;  p[j+1]，此时匹配失效，暴力写我们会在从p串的头部开始，而此时我们求出的next数组，得出上图中的1串和3串是相等的，因此我们直接让p串的1串移动到3串位置，也就是 j  &#x3D; next[j] , 比如到第6个字符不匹配了，让5 &#x3D; next[5], 上上图的next[5] 是2，也就是从abcab的第一个b开始匹配了，而不是从a从头匹配</p>
<p><strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串下标从1开始匹配</span><br><span class="line">next数组从2开始求，因为1只有一个元素，不存在非平凡前缀和后缀，next[1] = null</span><br></pre></td></tr></table></figure>



<h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</span><br><span class="line"></span><br><span class="line">模板串 P 在模式串 S 中多次作为子串出现。</span><br><span class="line"></span><br><span class="line">求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数 m，表示字符串 P 的长度。</span><br><span class="line"></span><br><span class="line">第二行输入字符串 P。</span><br><span class="line"></span><br><span class="line">第三行输入整数 n，表示字符串 S 的长度。</span><br><span class="line"></span><br><span class="line">第四行输入字符串 S。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤m≤1e5</span><br><span class="line">1≤n≤1e6</span><br><span class="line">输入样例：</span><br><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br><span class="line">输出样例：</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line"></span><br><span class="line">char p[N], s[N];</span><br><span class="line">int n, m;</span><br><span class="line">int ne[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p + 1 &gt;&gt; n &gt;&gt; s + 1; // 下标从1开始</span><br><span class="line">    </span><br><span class="line">    // next数组 next[1] 是空集，跳过，从2开始</span><br><span class="line">    for (int i = 2, j = 0; i &lt;= m; i ++)&#123;</span><br><span class="line">        while (j &amp;&amp; p[i] != p[j+1]) j = ne[j]; // 匹配不上，退而求其次</span><br><span class="line">        if (p[i] == p[j+1]) j ++; // 匹配得上，继续匹配</span><br><span class="line">        ne[i] = j;  // 记录当前ne数组</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 匹配过程 于求next过程基本一致</span><br><span class="line">    for (int i = 1, j = 0; i &lt;= n; i ++)&#123;</span><br><span class="line">        while (j &amp;&amp; s[i] != p[j+1]) j = ne[j];</span><br><span class="line">        if (s[i] == p[j+1]) j ++;</span><br><span class="line">        if(j == m) &#123; // 匹配串p完全匹配后，输出</span><br><span class="line">            cout &lt;&lt; i - m &lt;&lt; &quot; &quot;; // 题目要求输出下标从0开始</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2022/04/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><p>使用单调队列，在O（n）复杂度下维护区间最值，这里需要使用单调队列</p>
<p><strong>单调递增队列：</strong>维护队列最小值在队头</p>
<p><strong>单调递减队列：</strong>维度队列最大值在队头</p>
<p><img src="/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.png" alt="image-20220425110912865"></p>
<h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个大小为 n≤10^6 的数组。</span><br><span class="line">有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</span><br><span class="line">你只能在窗口中看到 k 个数字。</span><br><span class="line">每次滑动窗口向右移动一个位置。</span><br><span class="line">以下是一个例子：</span><br><span class="line">该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。</span><br><span class="line"></span><br><span class="line">窗口位置            最小值 最大值</span><br><span class="line">[1 3 -1] -3 5 3 6 7  -1     3</span><br><span class="line">1 [3 -1 -3] 5 3 6 7  -3     3</span><br><span class="line">1 3 [-1 -3 5] 3 6 7  -3     5</span><br><span class="line">1 3 -1 [-3 5 3] 6 7  -3     5</span><br><span class="line">1 3 -1 -3 [5 3 6] 7   3     6</span><br><span class="line">1 3 -1 -3 5 [3 6 7]   3     7</span><br><span class="line">你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">输入包含两行。</span><br><span class="line">第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</span><br><span class="line">第二行有 n 个整数，代表数组的具体数值。</span><br><span class="line">同行数据之间用空格隔开。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出包含两个。</span><br><span class="line">第一行输出，从左至右，每个位置滑动窗口中的最小值。</span><br><span class="line">第二行输出，从左至右，每个位置滑动窗口中的最大值。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line">输出样例：</span><br><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<p>code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line"></span><br><span class="line">int n,m,k;</span><br><span class="line">int a[N];</span><br><span class="line">deque&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">    </span><br><span class="line">    	while (!q.empty() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();</span><br><span class="line">		while (!q.empty() &amp;&amp; a[q.back()] &gt;= a[i]) q.pop_back();</span><br><span class="line">		q.push_back(i);</span><br><span class="line"> 		if (i - k + 1 &gt;= 0) cout &lt;&lt; a[q.front()] &lt;&lt; &quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	puts(&quot;&quot;);</span><br><span class="line">	q.clear();</span><br><span class="line">	for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">    	</span><br><span class="line">    	while (!q.empty() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();</span><br><span class="line">		while (!q.empty() &amp;&amp; a[q.back()] &lt;= a[i]) q.pop_back();</span><br><span class="line">		q.push_back(i);</span><br><span class="line"> 		if (i - k + 1 &gt;= 0) cout &lt;&lt; a[q.front()] &lt;&lt; &quot; &quot;;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<p><strong>solve()解释：</strong></p>
<p>双端队列q存储的是下标，对最小值模拟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">窗口位置            最小值 </span><br><span class="line">[1 3 -1] -3 5 3 6 7  -1     </span><br><span class="line">1 [3 -1 -3] 5 3 6 7  -3     </span><br><span class="line">1 3 [-1 -3 5] 3 6 7  -3     </span><br><span class="line">1 3 -1 [-3 5 3] 6 7  -3     </span><br><span class="line">1 3 -1 -3 [5 3 6] 7   3     </span><br><span class="line">1 3 -1 -3 5 [3 6 7]   3     </span><br><span class="line"></span><br><span class="line">1是第一个，入队</span><br><span class="line">3小于1，入队</span><br><span class="line">-1均小于1和3，1和3弹出队列，-1入队</span><br><span class="line">此时区间长度达到k=3，输出队头 -1</span><br><span class="line">-3 小于 -1，-1弹出，-3入队</span><br><span class="line">i-k+1 始终大于 0，后续每次操作都会输出队头</span><br><span class="line">这里while (!q.empty() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front()</span><br><span class="line">维护的是区间长度：i-k+1 是区间头部的下标，q,front是队列的第一个下标，当区间头部大于队首，就要弹出队首</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>有向图的拓扑排序</title>
    <url>/2022/05/17/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>入度：</strong> 指向一个点的边有多少个</p>
<p><strong>出度：</strong> 一个点指向的边的个数</p>
<p><img src="/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/1.jpg"></p>
<p>当一个图能够进行拓扑排序，那么这个图是有向无环图</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。 例如，在日常工作中，可能会将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。 为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。</p>
<h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol>
<li><p>选择入度为零的点作为顶点并输出</p>
</li>
<li><p>删除顶点和其关联的边</p>
</li>
<li><p>重复上述操作至不存在任何点</p>
</li>
</ol>
<h2 id="样例演示"><a href="#样例演示" class="headerlink" title="样例演示"></a>样例演示</h2><p><img src="/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/2.jpg"></p>
<p>上图中a入度为0，a为顶点，删除a和a相关的边</p>
<p>之后b c 入读为0 b c 为顶点 删除相关的边</p>
<p>只剩d 删除d，得到空集 证明是有向无环图</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>from acwing 848</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。</span><br><span class="line"></span><br><span class="line">请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。</span><br><span class="line"></span><br><span class="line">若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</span><br><span class="line"></span><br><span class="line">否则输出 −1。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n,m≤105</span><br><span class="line">输入样例：</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">输出样例：</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong>从a指向b，让a为头节点，b作为a的邻接表的插入点进行插入操作并记录入度情况</p>
<p>让入度为0的店进入队列，依次读取队列，删除队列的点和相关的边，同时让队列被删除的点的下一个点的入度减一</p>
<p>当所有点都进入队列，证明是可以拓扑排序的</p>
<p><strong>code:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int n, m, tt, hh;</span><br><span class="line">int h[N],q[N],d[N]; // h[x]是以x为链表头</span><br><span class="line">int idx;</span><br><span class="line">int ne[N],e[N]; // e[]存储当前结点的值，ne[]存储当前结点的下一结点的位置</span><br><span class="line"></span><br><span class="line">void add(int a, int b)&#123;  // b插入到a为头节点的邻接表</span><br><span class="line">	e[idx] = b;</span><br><span class="line">	ne[idx] = h[a];</span><br><span class="line">	h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool topsort()&#123;</span><br><span class="line">	hh = 0, tt = -1;</span><br><span class="line">	for (int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">		if (!d[i]) q[++tt] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	while(hh &lt;= tt)&#123;</span><br><span class="line">		int t = q[hh++]; // 读取队头，头节点并指向下一位</span><br><span class="line">		for (int i =h[t]; i != -1; i = ne[i])&#123; // 邻接表的遍历</span><br><span class="line">			int j = e[i];</span><br><span class="line">			d[j] --;  // 该点连接表头，删去表头，入度减一</span><br><span class="line">			if (!d[j]) q[++tt] = j; // 当入度为0,作为顶点入队</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (n - 1 == tt) return true; // tt从0计数</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	int a, b;</span><br><span class="line">	memset(h,-1,sizeof(h));</span><br><span class="line">	for (int i = 0; i &lt; m; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		add(a, b);</span><br><span class="line">		d[b] ++; </span><br><span class="line">	&#125;</span><br><span class="line">	if (topsort()) for (int i = 0; i &lt; n; i ++) cout &lt;&lt; q[i] &lt;&lt; &quot; &quot;; // q按照邻接表顺序读取，因此下标从0开始</span><br><span class="line">	else cout &lt;&lt; -1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>matlab笔记</title>
    <url>/2022/04/20/matlab%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="matlab下标从1开始"><a href="#matlab下标从1开始" class="headerlink" title="matlab下标从1开始"></a>matlab下标从1开始</h2><h2 id="cell"><a href="#cell" class="headerlink" title="cell"></a>cell</h2><p>cell 理解为 c中struct，承载各种变量</p>
<p>a &#x3D; cell(1,6)    1行6列的cell     </p>
<p>赋值及查找：a{1} &#x3D; ？</p>
<h2 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h2><p>magic(n)形成n*n的矩阵，特点：行列主副对角线和相等</p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>python中的字典</p>
<p>用逗号隔开</p>
<p>a &#x3D;  struct(‘key1’ ,’value1’,’key2’,’value2’)</p>
<p>  查找：a.key1 &#x3D;&#x3D;&gt; value1</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>a &#x3D; [ ;  ;  ;]</p>
<p>生成start到end，步长为step的一行矩阵：b &#x3D; start:step:end </p>
<p>将矩阵重复n行n列：repmat（矩阵，行，列）</p>
<p>n行n列的全1矩阵:ones（n,n）</p>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><p>a * b的转置：e &#x3D; a * b’</p>
<p>矩阵对应项相乘：a .* b</p>
<p>a*b的逆：a  &#x2F; b</p>
<p>a * b的逆的对应项： a .&#x2F; b</p>
<p>逆矩阵: inv(a)</p>
<h3 id="矩阵下标"><a href="#矩阵下标" class="headerlink" title="矩阵下标"></a>矩阵下标</h3><p>a的2行3列：a(2,3)</p>
<p>a的第一行：a(1,:)</p>
<p>find():以矩阵形式返回坐标： 查找大于3的： [m,n] &#x3D; find(a &gt; 3)</p>
<h2 id="循环-分支"><a href="#循环-分支" class="headerlink" title="循环 分支"></a>循环 分支</h2><p>for .. end</p>
<p>求 1到5的和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = 0;</span><br><span class="line">for i = 1:5</span><br><span class="line">	sum = sum + i;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>



<p>while  .. end</p>
<p>求1 到 5 的 和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = 0;</span><br><span class="line">i = 1;</span><br><span class="line">while i &lt; 5</span><br><span class="line">	s = s + i;</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>



<p>if .. end</p>
<p>if .. else .. end</p>
<p>if .. elseif ..  end</p>
<p>swith .. case .. end</p>
<h2 id="二维绘图"><a href="#二维绘图" class="headerlink" title="二维绘图"></a>二维绘图</h2><p>figure ：建立一个幕布</p>
<p>plot（x,y） ： 绘制当前二维图横轴下，纵轴y</p>
<p>title（‘   ’) :标题</p>
<p>xlabel(‘ x’) : x轴标签</p>
<p>ylabel(‘y’) : y轴标签</p>
<p>xlim([a,b]):  x坐标的范围(a,b)</p>
<p>plotyy （x,y1,x,y2,’plot’）: 共用一个x坐标系</p>
<p>绘制 y &#x3D; sin(x) :</p>
<p><strong>先绘制图像，标签名称在这之后添加</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 0:0.01:2*pi;</span><br><span class="line">y = sin(x);</span><br><span class="line">plot(x,y)</span><br><span class="line">title(&#x27;y=sin(x)&#x27;)</span><br><span class="line">xlabel(&#x27;x&#x27;)</span><br><span class="line">ylabel(&#x27;sin(x)&#x27;)</span><br><span class="line">xlim([0,2*pi])</span><br></pre></td></tr></table></figure>



<h2 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h2><p>绘图：plot3(x,y,z)</p>
<p>grid on:背景加网格线</p>
<p>axis square : 背景设置为正方体</p>
]]></content>
      <categories>
        <category>matlab</category>
      </categories>
  </entry>
  <entry>
    <title>bellman-ford算法</title>
    <url>/2022/05/25/bellman-ford%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>bellman_ford算法可以存在<strong>负权回路</strong>，因为它求得的最短路是有限制的，是限制了边数的，这样不会永久的走下去，会得到一个解；<br>SPFA算法各方面优于该算法，但是在碰到<strong>限制</strong>了最短路径上边的长度时就只能用bellman_ford了，此时直接把n重循环改成k次循环即可</p>
<h3 id="为什么dijkstra不适用用负权边"><a href="#为什么dijkstra不适用用负权边" class="headerlink" title="为什么dijkstra不适用用负权边"></a>为什么dijkstra不适用用负权边</h3><p><img src="/bellman-ford%E7%AE%97%E6%B3%95/1.png" alt="image-20220525080953218"></p>
<p>使用dijsktra算法：找到未标识的的距离源点最近的点1号点距离为0，2号点更新为2， 3号点更新为5</p>
<p>找到未标识的的距离源点最近的点2号点距离为2，2号点更新其他点的距离，4号更新为4</p>
<p>找到了未标识且离源点1最近的结点4，标识4号点，用4号点更新其他所有点的距离，5号点被更新成dist[5] &#x3D; 5</p>
<p>找到了未标识且离源点1最近的结点3，标识3号点，用3号点更新其他所有点的距离，4号点被更新成dist[4] &#x3D; 3</p>
<p>可以看到<code>1-&gt;2-&gt;4-&gt;5</code>并不是最短路</p>
<h3 id="bellman-ford算法实际应用"><a href="#bellman-ford算法实际应用" class="headerlink" title="bellman-ford算法实际应用"></a>bellman-ford算法实际应用</h3><p>从a到b地，可以有多个周转方案，但每周转一次乘客的耐心会下降一次，求在最多周转k次情况下，乘客可以在最短的路径下到达b地</p>
<h3 id="bellman-ford算法详解"><a href="#bellman-ford算法详解" class="headerlink" title="bellman-ford算法详解"></a>bellman-ford算法详解</h3><p>bellman-ford算法代码跟dijkstra算法基本一致，需要注意的是backup[]数组</p>
<p>backup[j]表示每次进入第2重循环的dist数组的备份。<br>如果不加这个备份的话有可能会发生节点最短距离的串连；</p>
<p><img src="/bellman-ford%E7%AE%97%E6%B3%95/2.png" alt="image-20220525082531688"></p>
<p>上图若边数限制为1，最短路径是3，按照dijkstra算法，存在串联的情况，利用本轮节点2更新了结点3的距离，最短路径变成了2</p>
<p>正确做法是，使用结点2上次更新的值：正无穷，更新结点3，所以结点3的距离是3</p>
<h3 id="为什么是dist-n-gt-0x3f3f3f3f-x2F-2，-而不是dist-n-gt-0x3f3f3f3f"><a href="#为什么是dist-n-gt-0x3f3f3f3f-x2F-2，-而不是dist-n-gt-0x3f3f3f3f" class="headerlink" title="为什么是dist[n]&gt;0x3f3f3f3f&#x2F;2， 而不是dist[n]&gt;0x3f3f3f3f"></a>为什么是dist[n]&gt;0x3f3f3f3f&#x2F;2， 而不是dist[n]&gt;0x3f3f3f3f</h3><p>5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。</p>
<p><img src="/bellman-ford%E7%AE%97%E6%B3%95/3.png" alt="image-20220525083339937"></p>
<h3 id="习题-acwing-853"><a href="#习题-acwing-853" class="headerlink" title="习题 acwing 853"></a>习题 acwing 853</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</span><br><span class="line"></span><br><span class="line">请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。</span><br><span class="line"></span><br><span class="line">注意：图中可能 存在负权回路 。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个整数 n,m,k。</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。</span><br><span class="line"></span><br><span class="line">如果不存在满足条件的路径，则输出 impossible。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤n,k≤500,</span><br><span class="line">1≤m≤10000,</span><br><span class="line">任意边长的绝对值不超过 10000。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">3 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 3 3</span><br><span class="line">输出样例：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 511, M = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int a, b, w;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line">int dist[N],backup[N];</span><br><span class="line">int n, m, k;</span><br><span class="line"></span><br><span class="line">void bellman_ford()&#123;</span><br><span class="line">	memset(dist, 0x3f, sizeof dist);</span><br><span class="line">	dist[1] = 0;</span><br><span class="line">	for (int i = 0; i &lt; k; i ++)&#123;</span><br><span class="line">		memcpy(backup, dist, sizeof dist);</span><br><span class="line">		for (int j = 0; j &lt; m; j ++)&#123;</span><br><span class="line">			auto t = edge[j];</span><br><span class="line">			dist[t.b] = min(dist[t.b],backup[t.a] + t.w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	for (int i = 0; i &lt; m;i ++)&#123;</span><br><span class="line">		int x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		edge[i] = &#123;x,y,z&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	bellman_ford();</span><br><span class="line">	if (dist[n] &gt; 0x3f3f3f3f/2) puts(&quot;impossible&quot;);</span><br><span class="line">	else cout &lt;&lt; dist[n];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/04/20/git/</url>
    <content><![CDATA[<p><strong>注：笔记来自yxc</strong></p>
<h1 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h1><p>工作区：仓库的目录。工作区是独立于各个分支的。<br>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。<br>版本库：存放所有已经提交到本地仓库的代码版本<br>版本结构：树结构，树中每个节点代表一个代码版本。</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<del>&#x2F;.gitconfig文件中<br><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在</del>&#x2F;.gitconfig文件中<br><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中<br><code>.gitignore</code>:编辑此文件可以选择忽略上传某些文件，写法：直接写入文件名即可</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git add XX </code>：将XX文件添加到暂存区<br><code>git commit -m</code> “给自己看的备注信息”：将暂存区的内容提交到当前分支<br><code>git status</code>：查看仓库状态<br><code>git log</code>：查看当前分支的所有版本<br><code>git push -u </code>(第一次需要-u以后不需要) ：将当前分支推送到远程仓库<br><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git branch</code>：查看所有分支和当前所处分支</p>
<h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<br><code>git status</code>：查看仓库状态<br><code>git log</code>：查看当前分支的所有版本<br><code>git log --pretty=oneline</code>：用一行来显示<br><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git pull</code> ：将远程仓库的当前分支与本地仓库的当前分支合并</p>
<h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉，不希望管理这个文件<br><code>git restore --staged xx</code>：&#x3D;&#x3D;将xx从暂存区里移除&#x3D;&#x3D;<br><code>git checkout — XX或git restore XX</code>：&#x3D;&#x3D;将XX文件尚未加入暂存区的修改全部撤销&#x3D;&#x3D;</p>
<h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><p><code>git reset --hard HEAD^ 或git reset --hard HEAD~ </code>：将代码库回滚到上一个版本<br><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推<br><code>git reset --hard HEAD~100</code>：往上回滚100个版本<br><code>git reset --hard</code> 版本号：回滚到某一特定版本</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库<br><code>git push -u (第一次需要-u以后不需要) </code>：将当前分支推送到远程仓库<br><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库<br><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git checkout -t origin/branch_name </code>将远程的branch_name分支拉取到本地<br><code>git pull </code>：将远程仓库的当前分支与本地仓库的当前分支合并<br><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并<br><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>
<h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><p><code>git branch branch_name</code>：创建新分支<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git checkout -t origin/branch_name </code>将远程的branch_name分支拉取到本地<br><code>git pull</code> ：将远程仓库的当前分支与本地仓库的当前分支合并<br><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并<br><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>
<h2 id="stash暂存"><a href="#stash暂存" class="headerlink" title="stash暂存"></a>stash暂存</h2><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>自定义ListView</title>
    <url>/2022/05/10/%E8%87%AA%E5%AE%9A%E4%B9%89ListView/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>listview是一个基本的控件，我们通过使用适配器，可以自定义列表视图，实现我们想要的视图，因此listview是相对比较频繁使用适配器adapter的，再次做个笔记。我们要实现一个类似qq的消息列表，列表每一项都要有头像，姓名，消息这三个属性</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.创建数据类，本案例实现一个StuData的实体类</p>
<p>2.自定义列表的每一项要展示的内容</p>
<p>3.自定义adapter，让list view能够使用这个adpter，修改本身的布局</p>
<p>4.在activity中初始化数据，加载布局</p>
<p><strong>总的来说，我们需要一个适配器来修改listview默认布局，加载布局需要用layoutinflater</strong></p>
<h2 id="样例演示"><a href="#样例演示" class="headerlink" title="样例演示"></a>样例演示</h2><h3 id="实现student实体类-StuData-java"><a href="#实现student实体类-StuData-java" class="headerlink" title="实现student实体类 StuData.java"></a>实现student实体类 StuData.java</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.it.ad_demo.MyListView;</span><br><span class="line"></span><br><span class="line">public class StuData &#123;</span><br><span class="line">    private int img;</span><br><span class="line">    private String name;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    // 定义学生的构造器 传参</span><br><span class="line">    public StuData(int img, String name, String content) &#123;</span><br><span class="line">        this.img = img;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getImg() &#123;</span><br><span class="line">        return img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImg(int img) &#123;</span><br><span class="line">        this.img = img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义列表的单项视图-mylistview-adpter-xml"><a href="#自定义列表的单项视图-mylistview-adpter-xml" class="headerlink" title="自定义列表的单项视图 mylistview_adpter.xml"></a>自定义列表的单项视图 mylistview_adpter.xml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;80dp&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_marginLeft=&quot;0dp&quot;</span><br><span class="line">        android:id=&quot;@+id/mylistview_image&quot;</span><br><span class="line">        android:layout_width=&quot;80dp&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/mylistview_name&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;0dp&quot;</span><br><span class="line">            android:layout_weight=&quot;2&quot;</span><br><span class="line">            android:textSize=&quot;30dp&quot;</span><br><span class="line">            android:text=&quot;123&quot;</span><br><span class="line">            android:textColor=&quot;@color/black&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/mylistview_content&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:textStyle=&quot;bold&quot;</span><br><span class="line">            android:layout_height=&quot;0dp&quot;</span><br><span class="line">            android:textSize=&quot;16dp&quot;</span><br><span class="line">            android:text=&quot;1213213321&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义adpter为MyListViewAdapter继承自BaseAdapter"><a href="#自定义adpter为MyListViewAdapter继承自BaseAdapter" class="headerlink" title="自定义adpter为MyListViewAdapter继承自BaseAdapter"></a>自定义adpter为MyListViewAdapter继承自BaseAdapter</h3><p>baseAdapter有四个方法，public int getCount()， public Object getItem(int position)， public long getItemId(int position)， public View getView(int position, View convertview，ViewGroup viewGroup)，因此在继承BaseAdapter类后必须实现这四个方法。</p>
<p><code>getCount()</code>:返回数据的数量</p>
<p><code>getItem()</code>：返回listview的Item，返回position即可，position是指每条Item在ListView中的位置，从0开始</p>
<p><code>getItemId()</code>：获得ListView中每条Item的Id的，这里我们依然返回position即可。</p>
<p><code> getView()</code>:将数据一一映射到自定义的布局，并返回这个布局</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.it.ad_demo.MyListView;</span><br><span class="line"></span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.BaseAdapter;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import com.it.ad_demo.R;</span><br><span class="line">import com.it.ad_demo.Service.IntentServiceActivity;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.zip.Inflater;</span><br><span class="line"></span><br><span class="line">public class MyListViewAdapter extends BaseAdapter &#123;</span><br><span class="line">    List&lt;StuData&gt; studata;</span><br><span class="line">    LayoutInflater layoutInflater;//定义Inflater,加载我们自定义的布局。</span><br><span class="line"></span><br><span class="line">    //定义构造器，在Activity创建对象Adapter的时候将数据data和Inflater传入自定义的Adapter中进行处理。</span><br><span class="line">    public MyListViewAdapter(List&lt;StuData&gt; studata, LayoutInflater layoutInflater) &#123;</span><br><span class="line">        this.studata = studata;</span><br><span class="line">        this.layoutInflater = layoutInflater;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 　返回数据数量</span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return studata.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 该方法使用来获得每一条ListView中的Item的，这里我们返回position即可，position是指每条Item在ListView中的位置（0， 1， 2……）</span><br><span class="line">    @Override</span><br><span class="line">    public Object getItem(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 该方法是来获得ListView中每条Item的Id的，这里我们依然返回position即可。</span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 该方法是自定义Adapter最重要的方法，在这个方法中我们需要将数据一一对应的映射或者添加到我们自己定义的View中。然后返回view。</span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View view, ViewGroup viewGroup) &#123;</span><br><span class="line">        // 获取自定义的listview的布局</span><br><span class="line">        View myview = layoutInflater.inflate(R.layout.mylistview_adapter,null);</span><br><span class="line">        // 获取学生对象</span><br><span class="line">        StuData stu = studata.get(position);</span><br><span class="line">        //获得自定义布局中每一个控件的对象。</span><br><span class="line">        ImageView photo = (ImageView) myview.findViewById(R.id.mylistview_image);</span><br><span class="line">        TextView name = (TextView) myview.findViewById(R.id.mylistview_name);</span><br><span class="line">        TextView content = (TextView) myview.findViewById(R.id.mylistview_content);</span><br><span class="line">        // 数据一一添加到布局</span><br><span class="line">        photo.setImageResource(stu.getImg());</span><br><span class="line">        name.setText(stu.getName());</span><br><span class="line">        content.setText(stu.getContent());</span><br><span class="line"></span><br><span class="line">        return myview;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="在activity中初始化数据，加载布局"><a href="#在activity中初始化数据，加载布局" class="headerlink" title="在activity中初始化数据，加载布局"></a>在activity中初始化数据，加载布局</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.it.ad_demo.MyListView;</span><br><span class="line"></span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.widget.ListView;</span><br><span class="line"></span><br><span class="line">import com.it.ad_demo.R;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MyListViewActivity extends AppCompatActivity &#123;</span><br><span class="line">    private ListView mylist;//这个activity默认布局</span><br><span class="line">    private List&lt;StuData&gt; studata;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_my_list_view);</span><br><span class="line"></span><br><span class="line">        // 加载布局</span><br><span class="line">        mylist = (ListView) findViewById(R.id.mylistview_list);</span><br><span class="line">        LayoutInflater inflater = getLayoutInflater();</span><br><span class="line">        // 初始化数据</span><br><span class="line">        init();</span><br><span class="line">        // 添加适配器，添加布局</span><br><span class="line">        MyListViewAdapter adapter = new MyListViewAdapter(studata,inflater);</span><br><span class="line">        mylist.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        studata = new ArrayList&lt;StuData&gt;();</span><br><span class="line">        StuData keqing = new StuData(R.drawable.keqing,&quot;keqing&quot;,&quot;hello keqing&quot;);</span><br><span class="line">        StuData xq = new StuData(R.drawable.keqing,&quot;xq&quot;,&quot;hello xq&quot;);</span><br><span class="line">        studata.add(keqing);</span><br><span class="line">        studata.add(xq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验效果："><a href="#实验效果：" class="headerlink" title="实验效果："></a>实验效果：</h3><p><img src="/%E8%87%AA%E5%AE%9A%E4%B9%89ListView/1.png"></p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
  </entry>
  <entry>
    <title>栈实现整数计算</title>
    <url>/2022/04/24/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><img src="/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E8%AE%A1%E7%AE%97/1.png" alt="image-20220424194517806"></p>
<p><strong>思路：</strong></p>
<p>num栈存储数字，op栈存储运算符和括号，另外开一个map存储加减乘除优先级</p>
<h3 id="处理数字："><a href="#处理数字：" class="headerlink" title="处理数字："></a>处理数字：</h3><p>一旦读取到数字，就进入循环，从这个数字一直往后读到不是数字的字符跳出</p>
<h3 id="处理括号："><a href="#处理括号：" class="headerlink" title="处理括号："></a>处理括号：</h3><p><strong>左括号：</strong>左括号没有注意的点，直接存入op</p>
<p><strong>右括号：</strong> 一旦读取到右括号，就开始计算括号内的数字，以读取到左括号为条件跳出</p>
<h3 id="处理运算符："><a href="#处理运算符：" class="headerlink" title="处理运算符："></a>处理运算符：</h3><p>开一个map存储优先级，+，- 的优先级低于 *  &#x2F;</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line">map&lt;char,int&gt; mp = &#123;&#123;&#x27;+&#x27; , 1&#125; , &#123;&#x27;-&#x27; , 1&#125; , &#123;&#x27;*&#x27; , 2&#125; , &#123;&#x27;/&#x27; , 2&#125;&#125;;</span><br><span class="line">bool st; // 当运算不合法，st为true作为判断条件</span><br><span class="line"></span><br><span class="line">void eval()&#123;</span><br><span class="line">    int a = num.top();</span><br><span class="line">    num.pop();</span><br><span class="line">    int b = num.top();</span><br><span class="line">    num.pop();</span><br><span class="line">    char c = op.top();</span><br><span class="line">    op.pop();</span><br><span class="line">    int ans = 0;</span><br><span class="line">    if (c == &#x27;+&#x27;) ans = a + b;</span><br><span class="line">    else if (c == &#x27;-&#x27;) ans = b - a;</span><br><span class="line">    else if (c == &#x27;*&#x27;) ans = a * b;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (!a) st = true;</span><br><span class="line">        else ans = b / a;</span><br><span class="line">    &#125;</span><br><span class="line">    num.push(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; s.size(); i ++)&#123;</span><br><span class="line">	    if (isdigit(s[i]))&#123;</span><br><span class="line">	        int ans = 0, j = i;</span><br><span class="line">	        while(isdigit(s[j])) ans = ans*10 + s[j ++] - &#x27;0&#x27;;</span><br><span class="line">	        num.push(ans);</span><br><span class="line">	        i = j - 1; // 12 + 3 -&gt;  j到 + 的位置跳出，i 调整为 2 的位置，下次循环i++，到+</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">    	else if (s[i] == &#x27;(&#x27;) op.push(s[i]);</span><br><span class="line">	    </span><br><span class="line">	    else if (s[i] == &#x27;)&#x27;) &#123;</span><br><span class="line">	        while(op.top() != &#x27;(&#x27;) eval();</span><br><span class="line">	        op.pop(); // op.top() == &#x27;(&#x27; ,弹出 &#x27;(&#x27;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    else&#123;</span><br><span class="line">        	// 当且仅当存在运算符且第一个运算符的优先级高于现在的运算符，计算当前运算符之前的表达式	    </span><br><span class="line">	        while (op.size() &amp;&amp; mp[op.top()] &gt;= mp[s[i]]) eval(); </span><br><span class="line">	        op.push(s[i]); // 条件不满足或运算完毕，将当前运算符入栈</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while (op.size()) eval(); // 处理剩下的无括号的运算</span><br><span class="line">	if (!st) cout &lt;&lt; num.top();</span><br><span class="line">	else cout &lt;&lt; &quot;error&quot;;</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2022/04/26/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HashMap 实现的是哈希表，用于解决O(1)的精确查找，无论是内存中实现程序逻辑还是外存中实现 key - value 存储，几乎无处不用</p>
<p>Trie 树即字典树&#x2F;前缀树，用于解决前缀检索（模糊查找），最经典的应用就是搜索 suggest，搜索”变形”，suggest 给你”变形金刚”</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>字典树 开辟一个空的头节点，譬如存储多个字符串的树形结构，从头部读入，若存在某一节点，则头指针指向它，不存在则开辟这个新节点</p>
<p>当存在大量字符串，26个字母最多只有26个分支，比哈希表更省空间，多用来实现输入提示</p>
<p><img src="/%E5%AD%97%E5%85%B8%E6%A0%91/1.png"></p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><strong>单词个数统计：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">维护一个字符串集合，支持两种操作：</span><br><span class="line"></span><br><span class="line">I x 向集合中插入一个字符串 x；</span><br><span class="line">Q x 询问一个字符串在集合中出现了多少次。</span><br><span class="line">共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 N，表示操作数。</span><br><span class="line"></span><br><span class="line">接下来 N 行，每行包含一个操作指令，指令为 I x 或 Q x 中的一种。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每个询问指令 Q x，都要输出一个整数作为结果，表示 x 在集合中出现的次数。</span><br><span class="line"></span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤2∗104</span><br><span class="line">输入样例：</span><br><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br><span class="line">输出样例：</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p><strong>哈希表解决：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    unordered_map&lt;string,int&gt; hash;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n --)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        char op;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; s;</span><br><span class="line">        if (op == &#x27;I&#x27;) hash[s] ++;</span><br><span class="line">        else cout &lt;&lt; hash[s] &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字典树解决：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e4 + 10, M = 26 * N; </span><br><span class="line"></span><br><span class="line">int idx;</span><br><span class="line">int cnt[N]; // 单词出现次数</span><br><span class="line">int te[M][30]; // 26个字母，26个分支，数据范围1e4,trie树范围最大为26*1e4</span><br><span class="line">char s[N];</span><br><span class="line"></span><br><span class="line">void insert(char ch[])&#123;</span><br><span class="line">    int h = 0; // 头节点</span><br><span class="line">    for (int i = 0; i &lt; strlen(ch); i ++)&#123;</span><br><span class="line">        int t = ch[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!te[h][t]) te[h][t] = ++ idx; // 当节点不存在，就开辟一个新节点</span><br><span class="line">        h = te[h][t]; // 头节点更新为当前的节点</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[h] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int search(char ch[])&#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    for (int i = 0; i &lt; strlen(ch); i ++)&#123;</span><br><span class="line">        int t = ch[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!te[h][t]) return 0;  </span><br><span class="line">        h = te[h][t];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[h];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n --)&#123;</span><br><span class="line">        char op;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; s;</span><br><span class="line">        if (op == &#x27;I&#x27;) insert(s);</span><br><span class="line">        else cout &lt;&lt; search(s) &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trie树应用："><a href="#trie树应用：" class="headerlink" title="trie树应用："></a>trie树应用：</h3><p><strong>习题：最大异或对</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行输入一个整数 N。</span><br><span class="line"></span><br><span class="line">第二行输入 N 个整数 A1～AN。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数表示答案。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1≤N≤105,</span><br><span class="line">0≤Ai&lt;231</span><br><span class="line">输入样例：</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">输出样例：</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>异或：</strong>相同为0，不同为1</p>
<p><strong>思路：</strong>暴力枚举O(n*n)TLE，将所有数字换成二进制，因此最多31位，存储到字典树；</p>
<p>要让异或最大，就尽量让当前数字的二进制在字典树中找到对应位相反的数字，1找0，0找1，若找不到，只能1找1，0找0，一直找到字典树的根节点，查找出这个数字,时间复杂度O(1e5 * 31) &#x3D; O(kn),在1e9内能过</p>
<p><img src="/%E5%AD%97%E5%85%B8%E6%A0%91/2.png"></p>
<p><strong>解释：</strong>如图，我们找2（010）的最大异或，0优先找1，1存在，继续2（010）的第二位1，1找0，存在，找第三位0，0找1，存在，查找的结果是101，也就是5</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10, M = 31*N;</span><br><span class="line"></span><br><span class="line">int a[N];</span><br><span class="line">int te[M][2];</span><br><span class="line">int idx;</span><br><span class="line"></span><br><span class="line">void insert(int x)&#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    for (int i = 30; i &gt;= 0; i --)&#123;</span><br><span class="line">        int t = x &gt;&gt; i &amp; 1; // 求数字的二进制的每一位</span><br><span class="line">        if (!te[h][t]) te[h][t] = ++idx;  // 找不到就开辟新节点</span><br><span class="line">        h = te[h][t]; // 头节点指向新节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int search(int x)&#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 30; i &gt;= 0; i --)&#123;</span><br><span class="line">        int t = x &gt;&gt; i &amp; 1;</span><br><span class="line">        if (te[h][!t])&#123; // 存在 1 异或 0 和 0 异或 1 的情况</span><br><span class="line">            res = 2 * res + 1; // 二进制进位乘2</span><br><span class="line">            h = te[h][!t]; </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            res = 2 * res + 0;</span><br><span class="line">            h = te[h][t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">        ans = max(ans, search(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2022/04/20/docker/</url>
    <content><![CDATA[<h3 id="docker-进入容器-docker-exec-it-docker-name-bin-bash"><a href="#docker-进入容器-docker-exec-it-docker-name-bin-bash" class="headerlink" title="docker 进入容器 docker exec -it docker_name /bin/bash"></a>docker 进入容器 <code>docker exec -it docker_name /bin/bash</code></h3><h3 id="将当前用户添加到docker用户组"><a href="#将当前用户添加到docker用户组" class="headerlink" title="将当前用户添加到docker用户组"></a>将当前用户添加到docker用户组</h3><p>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：<br><code>sudo usermod -aG docker $USER</code></p>
<h3 id="镜像（images）"><a href="#镜像（images）" class="headerlink" title="镜像（images）"></a>镜像（images）</h3><p>docker pull ubuntu:20.04：拉取一个镜像<br>docker images：列出本地所有镜像<br>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04<br>docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像<br>docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中<br>docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来</p>
<h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>docker ps -a：查看本地的所有容器<br>docker [container] start CONTAINER：启动容器<br>docker [container] stop CONTAINER：停止容器<br>docker [container] restart CONTAINER：重启容器<br>docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器<br>docker [container] attach CONTAINER：进入容器<br>先按Ctrl-p，再按Ctrl-q可以挂起容器<br>docker [container] exec CONTAINER COMMAND：在容器中执行命令<br>docker [container] rm CONTAINER：删除容器<br>docker container prune：删除所有已停止的容器<br>docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中<br>docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>docker export&#x2F;import与docker save&#x2F;load的区别：<br>export&#x2F;import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>save&#x2F;load会保存完整记录，体积更大<br>docker top CONTAINER：查看某个容器内的所有进程<br>docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br>docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件<br>docker rename CONTAINER1 CONTAINER2：重命名容器<br>docker update CONTAINER –memory 500MB：修改容器限制</p>
<h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><p>docker run -it –name&#x3D;c1 -p 80:80 -v &#x2F;home&#x2F;test&#x2F;web:&#x2F;web centos:7 &#x2F;bin&#x2F;bash # 启动容器<br>docker run -id –name&#x3D;c2 -p 80:80 -v &#x2F;home&#x2F;test&#x2F;web:&#x2F;web centos:7           # 后台启动容器<br>-it 交互式容器(-t终端,-i标准输入保持打开)<br>-id 守护式容器(-d后台)<br>–name 指定容器名称<br>-v 宿主机目录(文件):容器内目录(文件) # 将宿主机的目录挂载到容器中<br>-p 宿主机端口号:容器端口号          # 将容器端口映射到宿主机中</p>
<p>docker exec -it c2 &#x2F;bin&#x2F;bash # 进入容器<br>docker ps                    # 查看正在运行的容器<br>docker ps -a                 # 查看所有容器<br>docker stop c2               # 停止容器(根据CONTAINER ID或NAMES指定)<br>docker rm c1                 # 删除容器</p>
<p>docker rm <code>docker ps -aq</code>    # 删除所有容器<br>docker rmi <code>docker images -q redis</code> # 删除所有仓库名为redis的镜像<br>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) # 停止并删除所有容器</p>
<h3 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h3><p>docker volume create vol-demo  # 创建一个名为 vol-demo 的数据卷<br>docker volume ls               # 查看所有的数据卷<br>docker volume inspect vol-demo # 查看 vol-demo 数据卷的信息<br>docker volume rm vol-demo      # 删除 vol-demo 数据卷<br>docker volume prune            # 删除无主数据<br>docker run -d -P –name web –mount source&#x3D;vol-demo,target&#x3D;&#x2F;web nginx # 挂载数据卷</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Android SQL存储</title>
    <url>/2022/05/14/Android-SQL%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>安卓存储方式分为五种：</p>
<h3 id="使用SharedPreferences存储数据"><a href="#使用SharedPreferences存储数据" class="headerlink" title="使用SharedPreferences存储数据"></a>使用SharedPreferences存储数据</h3><p>适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等</p>
<h3 id="文件存储数据"><a href="#文件存储数据" class="headerlink" title="文件存储数据"></a>文件存储数据</h3><p>文件存储是最基本的存储方式，他会原封不动的数据存储到文件里面，适合一些比<strong>较小的二进制数据</strong>或者<strong>简单的文本数据</strong>。</p>
<h3 id="SQLite数据库存储数据"><a href="#SQLite数据库存储数据" class="headerlink" title="SQLite数据库存储数据"></a>SQLite数据库存储数据</h3><p>SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能。现在的主流移动设备像Android、iPhone等都使用SQLite作为复杂数据的存储引擎，在我们为移动设备开发应用程序时，也许就要使用到SQLite来存储我们大量的数据，所以我们就需要掌握移动设备上的SQLite开发技巧</p>
<h3 id="使用ContentProvider存储数据"><a href="#使用ContentProvider存储数据" class="headerlink" title="使用ContentProvider存储数据"></a>使用ContentProvider存储数据</h3><p>　Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个ContentProvider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用ContentProvider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。</p>
<h3 id="网络存储数据"><a href="#网络存储数据" class="headerlink" title="网络存储数据"></a>网络存储数据</h3><p>网络一般用于需要实时传输数据，由于移动产生流量需要资费，并且现在中国大陆地区的网络速度不尽人意，所以通过网络发送数据时需要注意数据量，如非必要，也不要使用网络发送。但是如果有些数据在移动端不能处理或者处理比较麻烦时，可以考虑通过网络发送到服务器处理。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>本文介绍的是SQLite存储方式</strong></p>
<h3 id="案例内容"><a href="#案例内容" class="headerlink" title="案例内容"></a>案例内容</h3><p>利用sql存储实现学生数据的增删改查</p>
<p>数据表包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id int(唯一)</span><br><span class="line">name char(20)</span><br><span class="line">content char(20)</span><br></pre></td></tr></table></figure>

<h3 id="案例实现思路"><a href="#案例实现思路" class="headerlink" title="案例实现思路"></a>案例实现思路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StuDB:创建并升级数据库</span><br><span class="line">StuData:javabean，存储学生类</span><br><span class="line">StuOP:数据库增删改查操作</span><br><span class="line">SqlDataActivity:演示界面</span><br></pre></td></tr></table></figure>



<h3 id="演示界面的xml"><a href="#演示界面的xml" class="headerlink" title="演示界面的xml:"></a>演示界面的xml:</h3><p>效果图:</p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/1.png"></p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;请输入信息：&quot;</span><br><span class="line">        android:textSize=&quot;25dp&quot;</span><br><span class="line">        android:textColor=&quot;@color/black&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_marginTop=&quot;10dp&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:text=&quot;姓名:&quot;/&gt;</span><br><span class="line">            &lt;EditText</span><br><span class="line">                android:id= &quot;@+id/Data_sql_editname&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:text=&quot;编号:&quot;/&gt;</span><br><span class="line">            &lt;EditText</span><br><span class="line">                android:id= &quot;@+id/Data_sql_editid&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:inputType=&quot;number&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;信息:&quot;/&gt;</span><br><span class="line">            &lt;EditText</span><br><span class="line">                android:id= &quot;@+id/Data_sql_editcontent&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/Data_sql_btinsert&quot;</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:text=&quot;添加&quot;/&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/Data_sql_btdel&quot;</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:text=&quot;删除&quot;/&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/Data_sql_btupdate&quot;</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:text=&quot;更新&quot;/&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/Data_sql_btquery&quot;</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:text=&quot;查询&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;查询结果：&quot;</span><br><span class="line">        android:textSize=&quot;25dp&quot;</span><br><span class="line">        android:textColor=&quot;@color/black&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:text=&quot;姓名:&quot;/&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id= &quot;@+id/Data_sql_showname&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:text=&quot;编号:&quot;/&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id= &quot;@+id/Data_sql_showid&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:layout_weight=&quot;1&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;信息:&quot;/&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id= &quot;@+id/Data_sql_showcontent&quot;</span><br><span class="line">                android:layout_width=&quot;0dp&quot;</span><br><span class="line">                android:layout_weight=&quot;4&quot;</span><br><span class="line">                android:textSize=&quot;25dp&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="StuDB类实现"><a href="#StuDB类实现" class="headerlink" title="StuDB类实现"></a>StuDB类实现</h3><p>该类继承自SQLiteOpenHelper，调用onCreate 和 OnUpdate方法即可</p>
<p>我们实现user数据表，包括id，name，content三个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.ad_demo1.Data.Sql;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper;</span><br><span class="line">import androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">public class StuDB extends SQLiteOpenHelper &#123;</span><br><span class="line"></span><br><span class="line">    public StuDB(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version)&#123;</span><br><span class="line">        super(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">        // 创建数据表</span><br><span class="line">        db.execSQL(&quot;create table user(id integer primary key autoincrement,&quot; +</span><br><span class="line">                &quot;name char(20), &quot; +</span><br><span class="line">                &quot;content char(20))&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</span><br><span class="line">        // 升级数据库，不处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="StuData-实现"><a href="#StuData-实现" class="headerlink" title="StuData 实现"></a>StuData 实现</h3><p>简单的javabean，同样要有包括id，name，content</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.ad_demo1.Data.Sql;</span><br><span class="line"></span><br><span class="line">public class StuData&#123;</span><br><span class="line">    private String name,content;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="StuOP-实现"><a href="#StuOP-实现" class="headerlink" title="StuOP 实现"></a>StuOP 实现</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void insert(int id, String name, String content)&#123;</span><br><span class="line">    SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">    // api 插入数据</span><br><span class="line">    ContentValues values = new ContentValues();</span><br><span class="line">    values.put(&quot;id&quot;,id);</span><br><span class="line">    values.put(&quot;name&quot;,name);</span><br><span class="line">    values.put(&quot;content&quot;,content);</span><br><span class="line">    // 参数默认为null即可</span><br><span class="line">    database.insert(&quot;user&quot;,null,values);</span><br><span class="line">    database.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>通过id直接删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void delete(int id)&#123;</span><br><span class="line">    SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">    // delete参数分别为：表名，以哪一个属性为key进行删除，该属性的值</span><br><span class="line">    database.delete(&quot;user&quot;,&quot;id=?&quot;,new String[]&#123;String.valueOf(id)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>以id为条件查询更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressLint(&quot;Range&quot;)</span><br><span class="line">public void update(int id, String name, String content)&#123;</span><br><span class="line">    Boolean isfind = false;</span><br><span class="line">    SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">    ContentValues values = new ContentValues();</span><br><span class="line">    values.put(&quot;name&quot;, name);</span><br><span class="line">    values.put(&quot;content&quot;, content);</span><br><span class="line">    // id=? 代表以id为条件查询</span><br><span class="line">    database.update(&quot;user&quot;, values, &quot;id=?&quot;, new String[]&#123;String.valueOf(id)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>以id为条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressLint(&quot;Range&quot;)</span><br><span class="line">  public StuData query(int id)&#123;</span><br><span class="line">      StuData stu = null;</span><br><span class="line">      SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">      ContentValues values = new ContentValues();</span><br><span class="line">      // 查询要建立游标</span><br><span class="line">      Cursor cursor = database.query(&quot;user&quot;,null,null,null,null,null,null);</span><br><span class="line">      while(cursor.moveToNext())&#123;// 当游标要移动到下一行</span><br><span class="line">          int stuid = cursor.getInt(cursor.getColumnIndex(&quot;id&quot;));</span><br><span class="line">          String stuname = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</span><br><span class="line">          String stucontent = cursor.getString(cursor.getColumnIndex(&quot;content&quot;));</span><br><span class="line">          if (stuid == id)&#123;// 当我们要查询的的id</span><br><span class="line">              stu = new StuData();</span><br><span class="line">              stu.setId(stuid);</span><br><span class="line">              stu.setName(stuname);</span><br><span class="line">              stu.setContent(stucontent);</span><br><span class="line">              database.close();</span><br><span class="line">              cursor.close();</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return stu;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="StuOP源码"><a href="#StuOP源码" class="headerlink" title="StuOP源码"></a>StuOP源码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.ad_demo1.Data.Sql;</span><br><span class="line"></span><br><span class="line">import android.annotation.SuppressLint;</span><br><span class="line">import android.content.ContentValues;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.database.Cursor;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">public class StuOP &#123;</span><br><span class="line">    // 创建数据库实例</span><br><span class="line">    private StuDB db;</span><br><span class="line">    public StuOP(Context context)&#123;</span><br><span class="line">        this.db = new StuDB(context,&quot;user.db&quot;,null,1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(int id, String name, String content)&#123;</span><br><span class="line">        SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">        // api 插入数据</span><br><span class="line">        ContentValues values = new ContentValues();</span><br><span class="line">        values.put(&quot;id&quot;,id);</span><br><span class="line">        values.put(&quot;name&quot;,name);</span><br><span class="line">        values.put(&quot;content&quot;,content);</span><br><span class="line">        database.insert(&quot;user&quot;,null,values);</span><br><span class="line">        database.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete(int id)&#123;</span><br><span class="line">        SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">        database.delete(&quot;user&quot;,&quot;id=?&quot;,new String[]&#123;String.valueOf(id)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;Range&quot;)</span><br><span class="line">    public void update(int id, String name, String content)&#123;</span><br><span class="line">        Boolean isfind = false;</span><br><span class="line">        SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">        ContentValues values = new ContentValues();</span><br><span class="line">        values.put(&quot;name&quot;, name);</span><br><span class="line">        values.put(&quot;content&quot;, content);</span><br><span class="line">        database.update(&quot;user&quot;, values, &quot;id=?&quot;, new String[]&#123;String.valueOf(id)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;Range&quot;)</span><br><span class="line">    public StuData query(int id)&#123;</span><br><span class="line">        StuData stu = null;</span><br><span class="line">        SQLiteDatabase database = db.getWritableDatabase();</span><br><span class="line">        ContentValues values = new ContentValues();</span><br><span class="line">        // 查询要建立游标</span><br><span class="line">        Cursor cursor = database.query(&quot;user&quot;,null,null,null,null,null,null);</span><br><span class="line">        while(cursor.moveToNext())&#123;</span><br><span class="line">            int stuid = cursor.getInt(cursor.getColumnIndex(&quot;id&quot;));</span><br><span class="line">            String stuname = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</span><br><span class="line">            String stucontent = cursor.getString(cursor.getColumnIndex(&quot;content&quot;));</span><br><span class="line">            if (stuid == id)&#123;</span><br><span class="line">                stu = new StuData();</span><br><span class="line">                stu.setId(stuid);</span><br><span class="line">                stu.setName(stuname);</span><br><span class="line">                stu.setContent(stucontent);</span><br><span class="line">                database.close();</span><br><span class="line">                cursor.close();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SqlDataActivity"><a href="#SqlDataActivity" class="headerlink" title="SqlDataActivity"></a>SqlDataActivity</h3><p>没什么好解释的，直接实例化StuOP类，设置点击事件即可，注意处理op操作的查询操作返回null的情况即可</p>
<p><strong>code:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.ad_demo1.Data.Sql;</span><br><span class="line"></span><br><span class="line">import androidx.appcompat.app.AppCompatActivity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Button;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import android.widget.Switch;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line">import com.example.ad_demo1.R;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class SqlDataActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    // 实例化操作类</span><br><span class="line">    private StuOP op;</span><br><span class="line">    private EditText editid,editname,editcontent;</span><br><span class="line">    private TextView showid,showname,showcontent;</span><br><span class="line">    private Button btinsert,btupdate,btquery,btdelete;</span><br><span class="line">    private String stuname,stucontent;</span><br><span class="line">    private int stuid;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_sql_data);</span><br><span class="line">        op = new StuOP(this);</span><br><span class="line">        editid = (EditText) findViewById(R.id.Data_sql_editid);</span><br><span class="line">        editname = (EditText) findViewById(R.id.Data_sql_editname);</span><br><span class="line">        editcontent = (EditText) findViewById(R.id.Data_sql_editcontent);</span><br><span class="line">        showid = (TextView) findViewById(R.id.Data_sql_showid);</span><br><span class="line">        showname = (TextView) findViewById(R.id.Data_sql_showname);</span><br><span class="line">        showcontent = (TextView) findViewById(R.id.Data_sql_showcontent);</span><br><span class="line">        btinsert = (Button) findViewById(R.id.Data_sql_btinsert);</span><br><span class="line">        btdelete = (Button) findViewById(R.id.Data_sql_btdel);</span><br><span class="line">        btupdate = (Button) findViewById(R.id.Data_sql_btupdate);</span><br><span class="line">        btquery = (Button) findViewById(R.id.Data_sql_btquery);</span><br><span class="line">        btinsert.setOnClickListener(this);</span><br><span class="line">        btdelete.setOnClickListener(this);</span><br><span class="line">        btquery.setOnClickListener(this);</span><br><span class="line">        btupdate.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每次操作要先清空Textview的内容</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        showid.setText(null);</span><br><span class="line">        showname.setText(null);</span><br><span class="line">        showcontent.setText(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        stuid = Integer.parseInt(editid.getText().toString().trim());</span><br><span class="line">        stuname = editname.getText().toString();</span><br><span class="line">        stucontent = editcontent.getText().toString();</span><br><span class="line">        switch (v.getId())&#123;</span><br><span class="line">            case R.id.Data_sql_btinsert:</span><br><span class="line">                init();</span><br><span class="line">                op.insert(stuid,stuname,stucontent);</span><br><span class="line">                Toast.makeText(this, &quot;信息添加成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case R.id.Data_sql_btdel:</span><br><span class="line">                init();</span><br><span class="line">                op.delete(stuid);</span><br><span class="line">                Toast.makeText(this, &quot;删除成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case R.id.Data_sql_btupdate:</span><br><span class="line">                init();</span><br><span class="line">                op.update(stuid,stuname,stucontent);</span><br><span class="line">                Toast.makeText(this, &quot;更新成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case R.id.Data_sql_btquery:</span><br><span class="line">                init();</span><br><span class="line">                StuData astu = op.query(stuid);</span><br><span class="line">                if (op.query(stuid) != null) &#123;</span><br><span class="line">                    showid.setText(String.valueOf(astu.getId()));</span><br><span class="line">                    showname.setText(astu.getName());</span><br><span class="line">                    showcontent.setText(astu.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">                else Toast.makeText(this, &quot;查无此人&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例演示："><a href="#案例演示：" class="headerlink" title="案例演示："></a>案例演示：</h2><p><strong>添加：</strong></p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/2.png" alt="image-20220514164314305"></p>
<p><strong>删除：</strong></p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/3.png" alt="image-20220514164433742"></p>
<p><strong>更新：</strong></p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/4.png" alt="image-20220514164700909"></p>
<p><strong>查询：</strong></p>
<p>当学生存在：</p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/5.png" alt="image-20220514164807014"></p>
<p>当学生不存在：</p>
<p><img src="/Android-SQL%E5%AD%98%E5%82%A8/6.png" alt="image-20220514164904989"></p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
  </entry>
</search>
